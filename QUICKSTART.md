# Walph Riggum - Quick Start Guide

## What Walph Needs to Run

Walph requires **3 things** in your project directory:

```
your-project/
├── specs/              # 1. Your requirements (what to build)
│   └── *.md
├── AGENTS.md           # 2. Project config (how to build/test)
└── IMPLEMENTATION_PLAN.md  # 3. Task list (generated by walph plan)
```

---

## Two Ways to Start

### Option A: New Project

Use `init` to create a new project from scratch.

### Option B: Existing Project

Use `setup` to add Walph to a project you already have.

---

## Option A: Initialize New Project

```bash
# From the ralphwiggum directory:
./walph.sh init my-project --stack node    # or: python, swift, kotlin

# This creates the directory structure with templates
cd my-project
```

---

## Option B: Setup Existing Project

```bash
# Navigate to your project
cd my-existing-project

# Run setup (auto-detects your stack)
/path/to/walph.sh setup

# Or specify the stack
/path/to/walph.sh setup --stack python
```

Walph will:
1. Create `.walph/` directory with prompts and config
2. Create `specs/` directory (if missing)
3. Create `AGENTS.md` with detected build commands (if missing)
4. Create `IMPLEMENTATION_PLAN.md` (if missing)

**Important:** Edit `AGENTS.md` to match your actual build/test commands!

---

## Step 2: Write Your Spec

Copy `specs/TEMPLATE.md` to a new file with your requirements. Walph reads ALL `.md` files in `specs/`.

### Spec Template

```markdown
# Feature: [Name]

## Overview
[1-2 sentences: What are we building?]

## Requirements

### Must Have
1. [Specific requirement]
2. [Specific requirement]
3. [Specific requirement]

### Nice to Have
1. [Optional feature]

## Technical Details

### Files to Create
- `src/main.js` - Entry point
- `src/utils.js` - Helper functions
- `tests/main.test.js` - Tests

### API/Interface (if applicable)
[Describe inputs, outputs, function signatures, endpoints, etc.]

## Acceptance Criteria
- [ ] [Testable criterion]
- [ ] [Testable criterion]
- [ ] [Testable criterion]

## Examples

### Example 1: [Name]
Input: [example input]
Output: [expected output]

### Example 2: [Name]
Input: [example input]
Output: [expected output]
```

### Good Spec Example

```markdown
# Feature: URL Shortener API

## Overview
Build a REST API that shortens URLs and redirects short codes to original URLs.

## Requirements

### Must Have
1. POST /shorten accepts a URL and returns a short code
2. GET /:code redirects to the original URL
3. Invalid codes return 404
4. Store mappings in memory (no database)

### Nice to Have
1. Track click counts

## Technical Details

### Files to Create
- `server.js` - Express server with routes
- `shortener.js` - URL shortening logic
- `server.test.js` - API tests

### API

POST /shorten
Request:  { "url": "https://example.com/long/path" }
Response: { "code": "abc123", "shortUrl": "http://localhost:3000/abc123" }

GET /:code
Response: 302 redirect to original URL, or 404 if not found

## Acceptance Criteria
- [ ] Can shorten a URL and get a code
- [ ] Can visit short code and get redirected
- [ ] Invalid codes return 404
- [ ] All tests pass

## Examples

### Shorten URL
Input: POST /shorten with {"url": "https://google.com"}
Output: {"code": "x7k9m2", "shortUrl": "http://localhost:3000/x7k9m2"}

### Redirect
Input: GET /x7k9m2
Output: 302 redirect to https://google.com
```

---

## Step 3: Configure AGENTS.md

Tell Walph how to build and test your project:

```markdown
# Project: my-project

## Build Commands

```bash
npm run build
```

## Test Commands

```bash
npm test
```

## Lint Commands

```bash
npm run lint
```

## Notes for Claude

- Use Express for the web server
- Use Node's built-in test runner
- Keep dependencies minimal
- Follow existing code patterns
```

### Key Sections

| Section | Purpose | Example |
|---------|---------|---------|
| Build Commands | How to compile/bundle | `npm run build`, `tsc`, `pip install -e .` |
| Test Commands | How to run tests | `npm test`, `pytest`, `node --test` |
| Lint Commands | How to check code style | `npm run lint`, `ruff check .` |
| Notes for Claude | Special instructions | Libraries to use, patterns to follow |

---

## Step 4: Run Planning

```bash
../walph.sh plan --max-iterations 2
```

Walph will:
1. Read all specs in `specs/`
2. Read `AGENTS.md`
3. Generate `IMPLEMENTATION_PLAN.md` with tasks

### Review the Plan

Open `IMPLEMENTATION_PLAN.md` and verify:
- Tasks are small and specific
- Order makes sense
- Nothing is missing

Edit manually if needed before building.

---

## Step 5: Run Building

```bash
../walph.sh build --max-iterations 20
```

Walph will loop:
1. Pick first unchecked task `- [ ]`
2. Implement it
3. Run tests
4. Mark complete `- [x]`
5. Commit
6. Repeat

### Monitor Progress

```bash
# Watch logs live
tail -f .walph/logs/walph_*.log

# Check status
../walph.sh status

# See git history
git log --oneline
```

---

## When Walph Stops

| Condition | Meaning |
|-----------|---------|
| `completion_level: HIGH` + `EXIT_SIGNAL: true` | All tasks done! |
| Max iterations reached | Hit limit, may need more |
| Circuit breaker: no changes | Stuck, not making progress |
| Circuit breaker: same error | Hitting same error repeatedly |

### If Stuck

```bash
# Reset circuit breaker
../walph.sh reset

# Check what's wrong
cat IMPLEMENTATION_PLAN.md
git diff
cat .walph/logs/walph_*.log | tail -100
```

---

## Directory Structure After Init

```
my-project/
├── .walph/
│   ├── config              # Override defaults here
│   ├── logs/               # Session logs
│   ├── state/              # Circuit breaker state
│   ├── PROMPT_plan.md      # Planning prompt (customizable)
│   └── PROMPT_build.md     # Building prompt (customizable)
├── specs/
│   └── TEMPLATE.md         # Your requirements go here
├── AGENTS.md               # Build/test commands
├── IMPLEMENTATION_PLAN.md  # Generated task list
└── .gitignore
```

---

## Command Reference

```bash
# Initialize new project
walph init <name> [--template <type>] [--stack <type>] [--docker] [--postgres]

# Run planning (generates IMPLEMENTATION_PLAN.md)
./walph.sh plan [--max-iterations N] [--model opus]

# Run building (implements from plan)
./walph.sh build [--max-iterations N] [--model sonnet]

# Check status
./walph.sh status

# Reset stuck state
./walph.sh reset

# Dry run (see what would happen)
./walph.sh build --dry-run
```

---

## Tips

1. **Start small** - First project should be simple (like the calculator example)
2. **Be specific in specs** - Vague requirements = vague results
3. **Include examples** - Show expected inputs/outputs
4. **List files to create** - Helps Walph understand scope
5. **Review the plan** - Edit `IMPLEMENTATION_PLAN.md` before building if needed
6. **Watch the logs** - `tail -f .walph/logs/*.log`
