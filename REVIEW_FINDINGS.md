# Code Review Findings

> Generated by Good Bunny on 2026-02-10 (iteration 9 — verified all findings against source, added 4 new findings). Run `goodbunny fix` to address findings.

## Summary
- **Project**: Walph Riggum (Autonomous Coding Loop + Jeeroy + Good Bunny)
- **Reviewed**: 2026-02-10
- **Total findings**: 53
- **Critical**: 2 | **High**: 11 | **Medium**: 19 | **Low**: 21

## Critical Findings

- [x] **[SECURITY]** `source "$project_config"` executes arbitrary code from user-controlled config files: Both `lib/config.sh:load_config()` (line 38) and `goodbunny.sh:load_goodbunny_config()` (line 142) use `source` to load config files from the project directory. Since `.walph/config` and `.goodbunny/config` are project files that could be committed to a repository, a malicious repository could include config files containing arbitrary shell commands that execute when `walph` or `goodbunny` is run.
  - File(s): `lib/config.sh` (line 38), `goodbunny.sh` (line 142)
  - Fix: Instead of `source`-ing the config files, parse them as key-value pairs using a safe reader. For example, read each line, validate it matches `^[A-Z_]+=.*$`, and use `declare` on validated lines only. Alternatively, use `grep` + parameter expansion to extract known config keys.

- [x] **[SECURITY]** `_relative_path()` in `converter.sh` passes unsanitized file paths into a Python command string: In `lib/converter.sh` (line 173), the function constructs a Python command with `$target` and `$base` directly interpolated into a `python3 -c` string: `python3 -c "import os; print(os.path.relpath('$target', '$base'))"`. If a filename contains a single quote (e.g., `doc's notes.pdf`), this breaks the Python string and could cause a Python injection. This is reachable via any document directory containing files with single quotes in their names.
  - File(s): `lib/converter.sh` (line 173)
  - Fix: Pass the paths as arguments to the Python script instead of interpolating them into the code string: `python3 -c "import os, sys; print(os.path.relpath(sys.argv[1], sys.argv[2]))" "$target" "$base"`. This avoids injection entirely.

## High Priority

- [x] **[ERROR HANDLING]** `check_api_error` has overly broad pattern matching that causes false positives: In `lib/status_parser.sh` (line 152), the function `check_api_error()` greps for `500|503|overloaded` in the raw Claude output. Since Claude output can contain arbitrary text (including code examples, documentation, or log output that mention "500" or "503"), this will trigger false API error detection on benign output. For example, Claude writing "HTTP status 500 handling" or a log line containing port 5003 would match.
  - File(s): `lib/status_parser.sh` (lines 149-156)
  - Fix: Make the pattern more specific. Match actual error patterns like `"Error: 500"`, `"HTTP 503"`, `"Internal Server Error"`, or look for specific Claude CLI error message formats. Consider anchoring patterns or matching against only the last ~10 lines of output where real errors appear.

- [x] **[ERROR HANDLING]** `extract_error_message` matches on any line containing "error" in Claude's entire output: In `lib/status_parser.sh` (line 164), the function greps for `error|failed|exception` across all of Claude's output. Since Claude produces substantial output including code, explanations, and logs, this function will frequently return false positives — e.g., a line like "Added error handling to the API" or "All tests passed with no exceptions" would be captured as an error message and fed into the circuit breaker's error pattern matching, potentially causing false same-error-repeated trips.
  - File(s): `lib/status_parser.sh` (lines 159-169)
  - Fix: Restrict error extraction to the last ~20 lines of output (where actual errors would appear), or only match patterns that indicate actual failures (e.g., lines starting with "Error:" or containing "FAILED" in test output). Consider also looking specifically at Claude's exit code rather than parsing output text.

- [x] **[DRY]** `run_iteration()` is almost entirely duplicated between `walph.sh` and `goodbunny.sh`: The `run_iteration()` function in `walph.sh` (lines 1323-1455) and `goodbunny.sh` (lines 295-447) are ~90% identical. Both create temp files, run Claude with background PID watchdog, handle timeout, check rate limits, check API errors, parse status, update circuit breaker, and check completion. The only differences are the template variable substitutions (goodbunny adds `{{CATEGORIES}}` and `{{FILES}}`).
  - File(s): `walph.sh` (lines 1323-1455), `goodbunny.sh` (lines 295-447)
  - Fix: Extract the shared iteration runner logic into a new `lib/runner.sh` library file. The function should accept a callback or additional parameters for tool-specific template substitutions. Both `walph.sh` and `goodbunny.sh` should source and call this shared function.

- [x] **[DRY]** `main_loop()` is duplicated between `walph.sh` and `goodbunny.sh`: The `main_loop()` function in `walph.sh` (lines 1457-1516) and `goodbunny.sh` (lines 453-515) follow the same pattern: iterate up to max, check circuit breaker, select prompt file, select model, run iteration, check completion signal file, increment. The differences are minor (different state directory paths, different model getter functions).
  - File(s): `walph.sh` (lines 1457-1516), `goodbunny.sh` (lines 453-515)
  - Fix: Extract into a shared `run_main_loop()` function in `lib/runner.sh` that accepts parameters for the state directory, model getter function, and prompt lookup paths.

- [x] **[DRY]** `create_agents_md` is defined three times with minor variations: The function exists in `walph.sh` (lines 456-534 for setup and 676-933 for init) and `init.sh` (lines 107-171). All three generate an `AGENTS.md` file with build/test/lint commands based on the stack, but each has a different level of detail and slightly different format.
  - File(s): `walph.sh` (lines 456-534, 676-933), `init.sh` (lines 107-171)
  - Fix: Consolidate into a single `create_agents_md()` function in a shared library (e.g., `lib/project_setup.sh`). Accept parameters for the level of detail needed (basic vs. detailed with structure). Both `walph.sh` and `init.sh` should call this shared function.

- [x] **[ERROR HANDLING]** `walph.sh` and `goodbunny.sh` lose the exit code from `run_iteration` in the `if/else` pattern: In `walph.sh` (lines 1489-1498) and `goodbunny.sh` (lines 489-498), the pattern `if run_iteration ...; then ... else result=$? ...` has a bug. When `run_iteration` fails, `$?` in the `else` branch captures the exit status of the condition test (always `1` for "false"), not the specific exit code from `run_iteration`. This means `result=$?` always gets `1`, and the `if [[ $result -eq 2 ]]` check (intended to detect user-requested exit from rate limit handling) will never trigger. Users who select "exit and resume later" during a rate limit prompt will not actually exit.
  - File(s): `walph.sh` (lines 1489-1498), `goodbunny.sh` (lines 489-498)
  - Fix: Capture the exit code before the `if`: `run_iteration "$iteration" "$prompt_file" "$model"; result=$?; if [[ $result -eq 0 ]]; then ... elif [[ $result -eq 2 ]]; then ... else ...`. This preserves the exact exit code from `run_iteration`.

- [x] **[ERROR HANDLING]** `set -e` combined with `if run_iteration` silently swallows non-zero exits from `run_iteration` sub-commands: Both `walph.sh` and `goodbunny.sh` use `set -euo pipefail`, which causes the script to exit on any unhandled error. However, `run_iteration` is called inside an `if` statement, which disables `set -e` for the entire function body (per bash semantics). This means any command inside `run_iteration` that fails (e.g., `cat "$temp_prompt"`, `wait "$claude_pid"`) will silently continue instead of aborting, potentially masking real errors. Combined with the `$?` capture bug above, error propagation from `run_iteration` is effectively broken.
  - File(s): `walph.sh` (line 1489), `goodbunny.sh` (line 1489)
  - Fix: Instead of `if run_iteration ...; then`, use `set +e; run_iteration ...; result=$?; set -e; if [[ $result -eq 0 ]]; then ...`. Or restructure to not rely on `set -e` for error handling within `run_iteration`, making all error handling explicit with `|| return` patterns.
  - Note: Fixed by extracting `run_iteration` logic into `lib/runner.sh` and calling it outside of conditional context (lib/runner.sh line 239-240). The exit code is now captured before the conditional check, preserving `set -e` behavior throughout the function call chain.

- [x] **[ERROR HANDLING]** `goodbunny.sh` circuit breaker thresholds silently inherit `lib/config.sh` defaults instead of goodbunny defaults: When `goodbunny.sh` sources `lib/config.sh` (line 21), `config.sh` sets `CIRCUIT_BREAKER_NO_CHANGE_THRESHOLD=3`, `CIRCUIT_BREAKER_SAME_ERROR_THRESHOLD=5`, and `CIRCUIT_BREAKER_NO_COMMIT_THRESHOLD=5` at file scope (config.sh lines 16-18). Later, `load_goodbunny_config()` (goodbunny.sh line 152-154) uses `${CIRCUIT_BREAKER_NO_CHANGE_THRESHOLD:-$GB_DEFAULT_CB_NO_CHANGE}` to set thresholds. Since the variables are already set by config.sh, the `:-` default expansion never triggers, and the goodbunny-specific defaults (`3/3/4`) are silently ignored for `SAME_ERROR` and `NO_COMMIT` — they keep the walph defaults of `5/5`. Only `NO_CHANGE` matches by coincidence (both are `3`).
  - File(s): `goodbunny.sh` (lines 174-176), `lib/config.sh` (lines 16-18)
  - Fix: In `load_goodbunny_config()`, unconditionally set the goodbunny-specific thresholds before the conditional override: `CIRCUIT_BREAKER_SAME_ERROR_THRESHOLD="${GOODBUNNY_CB_SAME_ERROR:-$GB_DEFAULT_CB_SAME_ERROR}"` (bypassing any previously set value). Or, change `lib/config.sh` to not set these at file scope — only set them inside `load_config()`.
  - Note: Fixed by unsetting the circuit breaker variables at the start of `load_goodbunny_config()` before applying goodbunny-specific precedence (env var > config file > goodbunny defaults).

- [x] **[SECURITY]** `sed` variable substitution in `run_iteration()` is vulnerable to injection via prompt content: In both `walph.sh` (lines 1342-1344) and `goodbunny.sh` (lines 313-315), template variables are substituted using `echo "$full_prompt" | sed "s/{{ITERATION}}/$iteration/g"`. The `$iteration` variable is numeric and safe, but in `goodbunny.sh` (lines 322-329), the `$categories_section` and `$files_section` are derived from user-provided `--categories` and `--files` arguments. Although there's an attempt to escape sed special chars with `sed 's/[&/\]/\\&/g'`, the backslash escaping in the character class `[&/\]` is itself problematic — the closing `\]` may be parsed as an escaped bracket on some sed implementations. More importantly, if the user passes `--files` or `--categories` values containing newlines or other special characters, the substitution can produce corrupted prompts or inject unintended content.
  - File(s): `goodbunny.sh` (lines 325-343), `lib/runner.sh` (lines 58-61)
  - Fix: Use a different substitution approach that avoids `sed` entirely. For example, use bash parameter expansion: `full_prompt="${full_prompt//\{\{CATEGORIES\}\}/$categories_section}"`. This handles arbitrary replacement content safely without needing to escape sed metacharacters.
  - Note: Fixed by replacing all sed-based template substitutions with bash parameter expansion in both `_gb_template_callback()` and `run_shared_iteration()`.

- [x] **[ERROR HANDLING]** `walph.sh` rate limit handler always shows `walph build` as resume command regardless of actual mode: The `handle_rate_limit()` function in `lib/utils.sh` (line 173) uses `${RESUME_COMMAND:-walph build}` for the resume message. While `goodbunny.sh` correctly exports `RESUME_COMMAND="goodbunny $MODE"` (line 187), `walph.sh` never sets `RESUME_COMMAND` anywhere. If a user is running `walph plan` and hits a rate limit, the prompt tells them to resume with `walph build` instead of `walph plan`.
  - File(s): `walph.sh` (entire file — missing `RESUME_COMMAND` export), `lib/utils.sh` (line 173)
  - Fix: Add `export RESUME_COMMAND="walph $MODE"` in `walph.sh`'s `init_walph()` function (around line 1550), similar to how `goodbunny.sh` does it at line 187.
  - Note: Fixed by adding `export RESUME_COMMAND="walph $MODE"` in `init_walph()` at line 1042.

## Medium Priority

- [x] **[COMPLEXITY]** `walph.sh` is a 1595-line monolith combining argument parsing, init, setup, and main loop: The `walph.sh` script handles 6 distinct commands (init, setup, plan, build, status, reset) plus all help text, template generation, Docker file creation, and the main iteration loop. This makes it hard to navigate, test, and maintain.
  - File(s): `walph.sh` (1595 lines)
  - Fix: Extract the `init` command logic (lines 1086-1317) into a separate file (it already partially exists as `init.sh`). Extract the `setup` command logic (lines 335-673) into `lib/setup.sh`. Keep `walph.sh` as a thin dispatcher that sources the relevant command module.
  - Note: Extracted setup command logic (parse_setup_args, show_setup_help, detect_stack, run_setup) to `lib/setup_command.sh`. File reduced from 1085 lines to 825 lines (260-line reduction). Init command logic extraction deferred to finding #85 which addresses init.sh duplication.

- [x] **[COMPLEXITY]** `create_agents_md()` in `walph.sh` is 257 lines with deep case nesting: The function at lines 676-933 in `walph.sh` has nested `case` statements (template inside stack) with large heredoc blocks for each combination. This creates a combinatorial explosion that's hard to maintain.
  - File(s): `walph.sh` (lines 676-933)
  - Fix: Use template files instead of inline heredocs. Create template fragments in `templates/agents/` for each stack and template combination, and assemble them in the function using variable substitution.

- [x] **[ERROR HANDLING]** Circuit breaker silently does nothing when `jq` is not installed: In `lib/circuit_breaker.sh`, both `_read_state()` (line 22) and `_update_state()` (line 30) check for `jq` and silently return empty/nothing if it's missing. The `check_dependencies()` function in `lib/utils.sh` (line 30) only warns about `jq` but doesn't prevent execution. This means the entire circuit breaker is non-functional without `jq`, but the user gets no indication of this — the loop will run indefinitely without the safety net.
  - File(s): `lib/circuit_breaker.sh` (lines 22-45), `lib/utils.sh` (lines 28-31)
  - Fix: Either make `jq` a required dependency (fail in `check_dependencies()` if missing), or implement a `jq`-free fallback for the circuit breaker state file (e.g., using `grep`/`sed` to parse the simple JSON structure, or switching to a plain key-value format).
  - Note: Fixed by making `jq` a required dependency — changed `check_dependencies()` in `lib/utils.sh` to add `jq` to the `missing` array instead of just logging a warning, ensuring execution fails if `jq` is not installed.

- [x] **[ERROR HANDLING]** `parse_args` in `walph.sh` and `goodbunny.sh` don't validate `--max-iterations` or `--model` arguments: At lines 84-89 in `walph.sh` and lines 84-98 in `goodbunny.sh`, `--max-iterations` does `shift 2` without checking if `$2` exists or is a number. Running `walph build --max-iterations` (without a value) will cause an unbound variable error with `set -u` or a confusing error. Same issue with `--model`, `--categories`, and `--files` in `goodbunny.sh`.
  - File(s): `walph.sh` (lines 84-89), `goodbunny.sh` (lines 84-98)
  - Fix: Add validation before `shift 2`: check that `$#` is >= 2, and for `--max-iterations`, validate that `$2` is a positive integer. Show a helpful error message if validation fails. Jeeroy already does this correctly (e.g., jeeroy.sh line 145: `if [[ $# -lt 2 ]]; then log_error ...`).
  - Note: Fixed by adding validation checks before shift operations. For --max-iterations, validates both argument existence and numeric format. For --model, --categories, and --files, validates argument existence.

- [x] **[ARCHITECTURE]** `init.sh` is a standalone duplicate of functionality already in `walph.sh init`: The `init.sh` script (519 lines) provides project initialization, but `walph.sh` also implements a full `init` command (lines 51-56, 122-175, 1086-1317) with more features (templates, docker, postgres flags). The `install.sh` script installs a `walph-init` wrapper pointing to `init.sh`, but `walph init` already works. Users may not know which to use.
  - File(s): `init.sh` (entire file), `walph.sh` (init-related sections)
  - Fix: Deprecate `init.sh` in favor of `walph.sh init` which has more features. Update `install.sh` to remove the `walph-init` wrapper, or make it call `walph init` instead of `init.sh`.
  - Note: Fixed by updating `install.sh` to make the `walph-init` wrapper call `walph.sh init` instead of `init.sh`, directing users to the more feature-rich implementation while maintaining the wrapper command for backward compatibility.

- [x] **[ERROR HANDLING]** Temp files in `walph.sh` and `goodbunny.sh` `run_iteration()` may leak on unexpected exit: In both `walph.sh` (lines 1362-1407) and `goodbunny.sh` (lines 357-399), temp files are created with `mktemp` but are only cleaned up in the happy path with `rm -f`. If the script is interrupted (SIGINT/SIGTERM) between temp file creation and cleanup, the temp files will remain on disk. Unlike `jeeroy.sh` which has a proper `trap cleanup_temp_files EXIT INT TERM` pattern (lines 27-45), the other scripts don't trap for temp file cleanup.
  - File(s): `walph.sh` (lines 1362-1407), `goodbunny.sh` (lines 357-399)
  - Fix: Add a trap-based cleanup mechanism similar to `jeeroy.sh` (lines 27-45). Track temp files in a global variable and register a trap to clean them up on EXIT/INT/TERM.
  - Note: Fixed by adding trap-based cleanup to `lib/runner.sh` (lines 19-39). Created `RUNNER_TEMP_FILES` tracking variable, `cleanup_runner_temp_files()` function, trap handler for EXIT/INT/TERM signals, and `make_runner_temp()` helper. Updated temp file creation in `run_shared_iteration()` to use the tracked temp files.

- [x] **[KISS]** `install.sh` doesn't install `goodbunny` wrapper: The `install.sh` script (lines 72-101) creates wrapper scripts for `walph`, `walph-init`, and `jeeroy`, but not for `goodbunny`. Similarly, `uninstall.sh` doesn't remove a `goodbunny` wrapper. This means `goodbunny` can't be used as a global command after installation.
  - File(s): `install.sh` (lines 72-101), `uninstall.sh` (lines 12-26)
  - Fix: Add a `goodbunny` wrapper creation block in `install.sh` (similar to the jeeroy wrapper at lines 93-101), and add removal of `goodbunny` in `uninstall.sh`.

- [x] **[ERROR HANDLING]** `check_commit_activity()` may fail on the first iteration due to empty `last_git_hash`: In `lib/circuit_breaker.sh`, `init_circuit_breaker()` (line 17) initializes `last_git_hash` to `""` (empty string). On the very first iteration, `check_commit_activity()` (lines 91-110) calls `git diff --name-only "$last_hash" "$current_hash"` where `$last_hash` is empty. This produces a git error, and the function falls through to `return 1` (no commit), causing `no_commit_count` to increment incorrectly on the first iteration even though no commit was expected yet.
  - File(s): `lib/circuit_breaker.sh` (lines 17, 91-110)
  - Fix: In `init_circuit_breaker()`, initialize `last_git_hash` to the current `HEAD` hash instead of an empty string: replace the empty `""` with `$(git rev-parse HEAD 2>/dev/null || echo "no-git")`. Alternatively, add a guard in `check_commit_activity()` to handle the empty-hash case by skipping the diff.

- [x] **[ARCHITECTURE]** `PROMPT_build.md` and `PROMPT_fix.md` instruct Claude to use `git add -A` which may stage unintended files: Both prompt templates instruct the autonomous Claude agent to use `git add -A` when committing (PROMPT_build.md line 151, PROMPT_fix.md line 76). `git add -A` stages all changes in the working directory, including files that may have been created unintentionally (temp files, debug logs, core dumps, etc.). This is particularly risky given that Claude runs with `--dangerously-skip-permissions` and could create files anywhere in the repo.
  - File(s): `templates/PROMPT_build.md` (line 151), `templates/PROMPT_fix.md` (line 76)
  - Fix: Change the prompt instructions to use `git add <specific files>` instead. Instruct Claude to explicitly list the files it changed and stage only those, or at minimum use `git add .` (stages from current directory, not entire repo).

- [x] **[ERROR HANDLING]** `_update_state()` in `circuit_breaker.sh` leaks temp file on `jq` failure: In `lib/circuit_breaker.sh` (lines 36-43), `_update_state()` creates a temp file with `mktemp` (line 37), pipes `jq` output to it, then `mv`s it into place. If `jq` fails (e.g., malformed JSON in state file), the `&&` prevents the `mv`, but the temp file from `mktemp` is never cleaned up. Over many iterations with a corrupted state file, this accumulates orphaned temp files in `/tmp`.
  - File(s): `lib/circuit_breaker.sh` (lines 36-43)
  - Fix: Add a trap or explicit cleanup: `jq ... > "$tmp_file" && mv "$tmp_file" "$CIRCUIT_BREAKER_STATE_FILE" || rm -f "$tmp_file"`.

- [x] **[KISS]** `completion_signal` file check is dead code — never written, only read: In both `walph.sh` (lines 1502-1505) and `goodbunny.sh` (lines 501-504), `main_loop()` checks for a `completion_signal` file in the state directory as a secondary completion detection mechanism. However, no code anywhere in the project ever creates this file. Completion is actually detected via the `check_completion()` return value in `run_iteration()`. This dead code path adds confusion about how completion works.
  - File(s): `walph.sh` (lines 1502-1505), `goodbunny.sh` (lines 501-504)
  - Fix: Remove the `completion_signal` file check from both `main_loop()` functions since it can never trigger. If the intent is to have a file-based completion mechanism, add code to `run_iteration()` to touch the file when `check_completion()` returns 0, and document the design in a comment.
  - Note: Fixed by DRY refactoring into `lib/runner.sh`. The `run_shared_iteration()` function now writes the completion signal file at line 203 when `check_completion()` returns 0, and `run_main_loop()` checks for it at line 274. Both walph.sh and goodbunny.sh now use the shared `run_main_loop()` implementation (false positive — mechanism was properly implemented during earlier refactoring).

- [x] **[ERROR HANDLING]** `run_analysis()` and `run_direct_generation()` in `jeeroy.sh` use `cat | claude` piping pattern that loses Claude CLI exit code on pipe failure: In `jeeroy.sh` (lines 346-348 and 440-442), both functions pipe the temp file to Claude via `cat "$temp_prompt" | claude -p ...`. With `set -o pipefail`, if `cat` fails (e.g., file was deleted), the pipe would propagate the error. However, the `if cat ... | claude ...; then` pattern disables `set -e` inside the conditional, meaning a `cat` failure will silently produce an empty stdin for Claude, and Claude will proceed with no input. The resulting empty output will then be treated as a valid analysis result.
  - File(s): `jeeroy.sh` (lines 346-348, 440-442)
  - Fix: Use input redirection instead of cat-pipe: `claude -p --model "$MODEL" < "$temp_prompt" > "$temp_output" 2>&1`. This is how `walph.sh` and `goodbunny.sh` already do it (e.g., walph.sh line 1375). It eliminates the UUOC and the pipe failure edge case.

- [x] **[ERROR HANDLING]** `_CONVERTER_TEMP_DIRS` in `converter.sh` is accumulated but never cleaned up via trap: In `lib/converter.sh` (line 256), the `convert_file()` function appends temp directories to `_CONVERTER_TEMP_DIRS` when extracting ZIP archives. Although the temp directories are cleaned up inline with `rm -rf "$temp_dir"` (lines 262, 267) on both success and failure of `unzip`, if the process is interrupted (SIGINT) between `mktemp -d` and the `rm -rf`, the temp dir will leak. The `_CONVERTER_TEMP_DIRS` variable exists but has no associated cleanup trap, making it dead code that gives a false impression of safety.
  - File(s): `lib/converter.sh` (line 256)
  - Fix: Either remove the `_CONVERTER_TEMP_DIRS` accumulation since inline cleanup handles it, or add a proper trap in `jeeroy.sh` (alongside the existing `cleanup_temp_files` trap) that iterates `_CONVERTER_TEMP_DIRS` and removes any leftover directories on exit.
  - Note: Fixed by extending the `cleanup_temp_files()` function in jeeroy.sh to also clean up `_CONVERTER_TEMP_DIRS` directories on EXIT/INT/TERM signals.

- [x] **[ARCHITECTURE]** `jeeroy.sh` doesn't set `LOG_PREFIX`, `LOG_FILE_PREFIX`, or `TOOL_NAME` before sourcing shared libraries, causing all console output to display as `[WALPH]` instead of `[JEEROY]`: In `jeeroy.sh` (lines 16-21), the script sources `lib/logging.sh` and `lib/utils.sh` without first setting the log identity variables. `goodbunny.sh` correctly sets `LOG_PREFIX="GOODBUNNY"`, `LOG_FILE_PREFIX="goodbunny"`, and `TOOL_NAME="Good Bunny"` on lines 16-18 before sourcing the libs. For `walph.sh`, the defaults in `logging.sh` ("WALPH", "walph", "Walph Riggum") are correct. But when running Jeeroy, all `log_info`, `log_error`, etc. messages display `[WALPH]` instead of `[JEEROY]`, which is confusing for users who may think they're running the wrong tool.
  - File(s): `jeeroy.sh` (lines 16-21)
  - Fix: Add identity exports before the `source` lines in `jeeroy.sh`, matching the pattern from `goodbunny.sh`: add `export LOG_PREFIX="JEEROY"`, `export LOG_FILE_PREFIX="jeeroy"`, `export TOOL_NAME="Jeeroy Lenkins"` before the `source` statements.

- [x] **[ERROR HANDLING]** `init.sh` sources `config.sh` late inside `create_walph_structure()` instead of at the top level: In `init.sh` (line 95), the function `create_walph_structure()` calls `source "$SCRIPT_DIR/lib/config.sh"` to access `write_default_config()`. However, this `source` happens inside a function body rather than at file scope. If `init.sh` is run standalone (which is supported via the `walph-init` wrapper), any `lib/config.sh` file-scope variables (like `CIRCUIT_BREAKER_*` thresholds) won't be set until this function is called, and `check_dependencies()` from `lib/utils.sh` is never available because `utils.sh` is never sourced. The script only sources `lib/logging.sh` at the top level (line 10), making `log_info` etc. available but not `command_exists`, `check_dependencies`, or other utils.sh functions — though currently `init.sh` doesn't call them, this limits extensibility and is inconsistent with how the other scripts set up their dependencies.
  - File(s): `init.sh` (lines 10, 95)
  - Fix: Move `source "$SCRIPT_DIR/lib/config.sh"` to the top level alongside `source "$SCRIPT_DIR/lib/logging.sh"`. Also consider sourcing `lib/utils.sh` for consistency, which would make `command_exists` and `check_dependencies` available for future use.
  - Note: Fixed by moving `source "$SCRIPT_DIR/lib/config.sh"` and `source "$SCRIPT_DIR/lib/utils.sh"` to the top level (lines 11-12), making all library functions available at file scope and ensuring consistent dependency setup across all scripts.

- [x] **[ERROR HANDLING]** `jeeroy.sh` does not source `lib/config.sh` and has no rate-limit handling for its non-interactive Claude phases: In `jeeroy.sh` (lines 16-21), the script sources `lib/logging.sh`, `lib/utils.sh`, and `lib/converter.sh` but not `lib/config.sh`. The `run_analysis()` (line 326) and `run_direct_generation()` (line 413) functions call Claude in non-interactive `-p` mode but do not check for rate limits in the output, unlike `walph.sh` and `goodbunny.sh` which call `check_rate_limit()` and `handle_rate_limit()` after every Claude invocation. If Claude's analysis or generation phase hits a rate limit, the user gets no actionable guidance — the error is either silently treated as analysis output or triggers a generic "analysis failed" message.
  - File(s): `jeeroy.sh` (lines 16-21, 326-355, 413-449)
  - Fix: Add rate-limit detection and handling to `run_analysis()` and `run_direct_generation()` by checking Claude's output for rate limit patterns (similar to how `walph.sh` and `goodbunny.sh` do it). Source `lib/status_parser.sh` for access to `check_rate_limit()`, or duplicate the simple grep check inline.
  - Note: Fixed by sourcing `lib/status_parser.sh` and adding rate limit checks after Claude calls in both `run_analysis()` and `run_direct_generation()`. Users now get clear guidance to wait and retry when hitting rate limits.

- [x] **[ERROR HANDLING]** `walph.sh` `run_iteration()` reads Claude output twice from temp file, second read may get stale data: In `walph.sh` (lines 1404-1407) and `goodbunny.sh` (lines 396-399), the temp output file is read twice: first `cat "$temp_output"` to display to terminal, then `output=$(cat "$temp_output")` to capture into a variable. Between these two reads, there's a tiny race window where the file could be modified. More practically, the double-read is wasteful for large outputs. The pattern should capture the output once and then echo it.
  - File(s): `walph.sh` (lines 1404-1407), `goodbunny.sh` (lines 396-399)
  - Fix: Capture the output first into the variable, then echo it: `output=$(cat "$temp_output"); echo "$output"; rm -f "$temp_output"`. This is both more efficient and avoids the double-read pattern.
  - Note: Fixed by reordering the operations in `lib/runner.sh` (lines 155-158) to capture output first, remove temp file, then display. This eliminates the double-read and race condition.

- [x] **[SECURITY]** `.claude/settings.local.json` contains stale permission entries referencing old `ralph.sh` script name: In `.claude/settings.local.json` (lines 13-17), several permission entries reference `ralph.sh` and `../ralph.sh` — script names from before the rename to `walph.sh`. These stale entries are harmless (they grant permission to a script that no longer exists), but they indicate the settings file was not updated during the rename. If someone re-creates `ralph.sh` (e.g., via symlink), these entries would grant it broad execution permissions unexpectedly.
  - File(s): `.claude/settings.local.json` (lines 13-17)
  - Fix: Remove the stale `ralph.sh` permission entries and replace them with equivalent `walph.sh` entries if needed. Clean up any other entries that reference the old name.

## Low Priority

- [x] **[DRY]** Docker file creation logic is duplicated between `walph.sh` and `init.sh`: Both `walph.sh:create_docker_files()` (lines 936-1033) and `init.sh:create_docker_setup()` (lines 309-393) create Docker configurations with slightly different formats and options.
  - File(s): `walph.sh` (lines 936-1033), `init.sh` (lines 309-393)
  - Fix: Consolidate into a shared function in a library file (e.g., `lib/docker.sh`) or use the template files that already exist in `templates/docker/`.
  - Note: Fixed by creating `lib/docker.sh` with shared `create_docker_setup()` function. Both `walph.sh` and `init.sh` now use the shared implementation, with `walph.sh` using a thin wrapper to maintain its existing interface.

- [x] **[DRY]** `.gitignore` creation logic is duplicated between `walph.sh` and `init.sh`: Both `walph.sh:run_init()` (lines 1263-1294) and `init.sh:create_gitignore()` (lines 396-441) create `.gitignore` files with slightly different contents (init.sh's version is more comprehensive, including coverage/ and .pytest_cache/).
  - File(s): `walph.sh` (lines 1263-1294), `init.sh` (lines 396-441)
  - Fix: Use a shared `.gitignore` template file in `templates/` and have both scripts copy from it.
  - Note: Fixed by creating `templates/gitignore.template` with the comprehensive version and updating both scripts to copy from it instead of using heredocs.

- [x] **[COMPLEXITY]** `_relative_path()` in `converter.sh` shells out to Python as a fallback: In `lib/converter.sh` (lines 162-178), the `_relative_path()` function tries `realpath --relative-to`, then falls back to `python3 -c "..."`, then to `basename`. The Python fallback is a heavyweight solution for a simple path operation and introduces a dependency on Python being installed.
  - File(s): `lib/converter.sh` (lines 162-178)
  - Fix: Implement a pure-bash relative path function, or simply use `basename` consistently since the relative paths are only used for display labels in source markers, not for functional purposes.
  - Note: Fixed by replacing Python fallback with pure bash string manipulation using parameter expansion (`${target#$base/}`). The function now tries `realpath --relative-to` first, then strips the base path prefix if the target is within the base directory, then falls back to `basename`.

- [ ] **[ARCHITECTURE]** `show_howto()` and `show_help()` in `lib/utils.sh` are Walph-specific but live in a shared library: The `show_howto()` (lines 249-381) and `show_help()` (lines 383-436) functions in `lib/utils.sh` contain Walph-specific content. Since `lib/utils.sh` is sourced by all three tools (walph, goodbunny, jeeroy), these Walph-specific functions pollute the namespace when running goodbunny or jeeroy.
  - File(s): `lib/utils.sh` (lines 249-436)
  - Fix: Move `show_howto()`, `show_help()`, and `show_version()` out of `lib/utils.sh` and into `walph.sh` directly, or into a dedicated `lib/walph_help.sh` that only `walph.sh` sources.

- [ ] **[KISS]** `log_iteration_start()` banner has hardcoded padding that breaks alignment with long iteration numbers: In `lib/logging.sh` (lines 98-107), the banner uses fixed padding after the iteration info text. When `iteration` or `max_iterations` are multi-digit (e.g., "Iteration 15 / 100"), the right edge of the box misaligns. This is cosmetic but looks broken.
  - File(s): `lib/logging.sh` (lines 98-107)
  - Fix: Either remove the right-side border character, or calculate padding dynamically based on the length of the iteration string using `printf` formatting.

- [ ] **[KISS]** `QUICKSTART.md` references `ralph_*.log` but actual log files use `walph_` prefix: In `QUICKSTART.md` (line 279), the command `cat .walph/logs/ralph_*.log | tail -100` references files starting with `ralph_`, but the actual logging in `lib/logging.sh` (line 42) uses `${LOG_FILE_PREFIX:-walph}_${session_id}.log`, which defaults to `walph_*`. Users following the quickstart guide would see no matching files.
  - File(s): `QUICKSTART.md` (line 279)
  - Fix: Change `ralph_*.log` to `walph_*.log` in the troubleshooting command.

- [ ] **[KISS]** `QUICKSTART.md` references `ralph_*.log` in a second location: In `QUICKSTART.md` (line 250), the monitoring command `tail -f .walph/logs/ralph_*.log` also uses the incorrect `ralph_` prefix.
  - File(s): `QUICKSTART.md` (line 250)
  - Fix: Change `ralph_*.log` to `walph_*.log` in the monitoring command as well.

- [ ] **[ERROR HANDLING]** `init.sh` `parse_args` doesn't validate `--stack` argument: In `init.sh` (lines 60-62), `--stack` does `shift 2` without checking if `$2` exists. Running `./init.sh my-project --stack` (without a value) will cause an unbound variable error with `set -u` or a confusing error. This is the same class of bug as the walph.sh/goodbunny.sh argument validation issue, but in a different script.
  - File(s): `init.sh` (lines 60-62)
  - Fix: Add a check before `shift 2`: `if [[ $# -lt 2 ]]; then log_error "--stack requires a type argument"; exit 1; fi`. Jeeroy already does this correctly.

- [ ] **[KISS]** `jeeroy.sh` writes `.jeeroy_context.md` to the project directory but doesn't add it to `.gitignore`: In `jeeroy.sh` (line 387), `run_qa_session()` writes a context file to `$PROJECT_DIR/.jeeroy_context.md`. While the file is cleaned up at line 406 with `rm -f`, if the script is interrupted (e.g., Ctrl+C during the interactive Q&A session, before line 406 runs), this file will remain in the project directory and could be accidentally committed. The trap at line 37 only cleans up tracked temp files via `$JEEROY_TEMP_FILES`, but `.jeeroy_context.md` is not tracked in that variable.
  - File(s): `jeeroy.sh` (lines 387, 406)
  - Fix: Either add `.jeeroy_context.md` to the `$JEEROY_TEMP_FILES` tracking variable so it's cleaned up by the EXIT trap, or use `make_temp()` to create the context file in `/tmp/` instead of in the project directory.

- [ ] **[DRY]** Chrome-devtools MCP detection logic is duplicated between `jeeroy.sh` and `install.sh`: Both `jeeroy.sh:validate_environment()` (lines 261-276) and `install.sh` (lines 44-54) contain identical logic to check for the chrome-devtools MCP by looking in two config file locations and grepping for "chrome-devtools". This same check could diverge over time.
  - File(s): `jeeroy.sh` (lines 261-276), `install.sh` (lines 44-54)
  - Fix: Extract the chrome-devtools MCP detection into a shared function in `lib/utils.sh` (e.g., `check_chrome_mcp()`) and call it from both scripts.

- [ ] **[KISS]** `QUICKSTART.md` references `Ralph` as the tool name in several user-facing messages: In `QUICKSTART.md`, lines 167, 261, 333, and 334 refer to "Ralph" (e.g., "Tell Ralph how to build", "When Ralph Stops", "List files to create — Helps Ralph understand scope"). The project has been renamed from Ralph to Walph, and these stale references may confuse users who only know the tool as "Walph."
  - File(s): `QUICKSTART.md` (lines 167, 261, 333, 334)
  - Fix: Replace "Ralph" with "Walph" in the user-facing text of `QUICKSTART.md`. Note: the `specs/README.md` template in `init.sh` (line 242) also references "Ralph" — change to "Walph" there too.

- [ ] **[KISS]** `.gitignore` comment says "Ralph" but tool is named "Walph": In `walph.sh` (line 1288), the generated `.gitignore` contains the comment `# Ralph (keep config and prompts, ignore state and logs)`. This is a stale reference from the rename. Users who read the `.gitignore` may be confused about which tool this comment refers to.
  - File(s): `walph.sh` (line 1288)
  - Fix: Change `# Ralph` to `# Walph Riggum` in the `.gitignore` comment.

- [ ] **[ERROR HANDLING]** `reset_circuit_breaker()` injects git hash directly into JSON string without escaping: In `lib/circuit_breaker.sh` (line 224), the `reset_circuit_breaker()` function embeds `$current_hash` directly into a hand-crafted JSON string: `echo "{...\"last_git_hash\":\"$current_hash\"...}"`. While `git rev-parse HEAD` typically outputs only hex characters, if the `|| echo "no-git"` fallback triggers, the value is safe, but this pattern is fragile. If the function is ever called in a context where the hash variable could contain special characters (e.g., modified by a shell alias), the JSON would be malformed. This contrasts with `_update_state()` which uses `jq --arg` for safe string interpolation.
  - File(s): `lib/circuit_breaker.sh` (line 224)
  - Fix: Use `jq` for the reset operation too, consistent with `_update_state()`: `jq -n --arg hash "$current_hash" '{"no_change_count":0,"same_error_count":0,"no_commit_count":0,"last_error":"","last_git_hash":$hash,"iteration_history":[]}' > "$CIRCUIT_BREAKER_STATE_FILE"`.

- [ ] **[KISS]** `init_goodbunny()` has redundant `MAX_ITERATIONS` check: In `goodbunny.sh` (lines 659-663), the function checks `if [[ -n "${MAX_ITERATIONS:-}" ]]; then :` — this is a no-op block that does nothing (the `:` command). The comment says "Already set from parse_args or load_goodbunny_config" but the `else` branch also sets it redundantly to `$GB_DEFAULT_MAX_ITERATIONS`, which `load_goodbunny_config()` at line 146 already guarantees. The entire if/else block is dead logic.
  - File(s): `goodbunny.sh` (lines 659-663)
  - Fix: Remove the entire if/else block since `load_goodbunny_config()` already ensures `MAX_ITERATIONS` is set.

- [ ] **[ARCHITECTURE]** `init.sh` comment on line 483 says "Create Ralph structure" but tool is named "Walph": In `init.sh` (line 483), the comment reads `# Create Ralph structure` but calls `create_walph_structure`. This is a minor stale reference from the rename.
  - File(s): `init.sh` (line 483)
  - Fix: Change `# Create Ralph structure` to `# Create Walph structure`.

- [ ] **[ERROR HANDLING]** `start_monitor_session()` in `walph.sh` uses a different session ID than the logging session: In `walph.sh` (line 1578), `start_monitor_session` calls `generate_session_id()` a second time: `start_monitor_session "$PROJECT_DIR/$LOG_DIR/walph_$(generate_session_id).log"`. But the logging session was already initialized at line 1544 with a different `session_id`. Since `generate_session_id()` is based on the current timestamp (`date '+%Y%m%d_%H%M%S'`), a one-second difference (or even the same second) produces a mismatched log file path. The tmux monitor pane would `tail -f` a file that doesn't exist or is different from the actual log file.
  - File(s): `walph.sh` (line 1578)
  - Fix: Reuse the `session_id` variable that was already computed at line 1543 instead of calling `generate_session_id()` again. Change line 1578 to: `start_monitor_session "$PROJECT_DIR/$LOG_DIR/walph_${session_id}.log" "$PROJECT_DIR"`. Note: `session_id` is a local variable in `init_walph()`, so it needs to be stored in a global or passed through.

- [ ] **[ERROR HANDLING]** `parse_init_args` and `parse_setup_args` in `walph.sh` don't validate `--template` and `--stack` arguments: In `walph.sh` `parse_init_args()` (lines 137-143), `--template` and `--stack` use `shift 2` without checking if `$2` exists. Similarly, `parse_setup_args()` (line 347) does `shift 2` for `--stack` without validation. Running `walph init my-app --template` (without a value) will cause an unbound variable error or a confusing error. This is the same bug class as the existing finding for `parse_args` main options, but in separate functions not covered by that finding.
  - File(s): `walph.sh` (lines 137-143 in `parse_init_args`, line 347 in `parse_setup_args`)
  - Fix: Add validation before `shift 2`: `if [[ $# -lt 2 ]]; then log_error "--template requires a type argument"; show_init_help; exit 1; fi`. Apply the same pattern to `--stack` in both functions.

- [ ] **[ERROR HANDLING]** `walph.sh` `run_init()` uses `git add .` in a subshell which may stage unintended files: In `walph.sh` (line 1305), the init flow runs `(cd "$target_dir" && git init && git add . && git commit -m "Initialize Walph Riggum project") 2>/dev/null || true`. The `git add .` stages everything in the project directory, which could include pre-existing files the user didn't intend to commit (e.g., if they ran `walph init .` in a directory with existing content). The `2>/dev/null || true` suffix additionally silences all errors, so the user gets no feedback if the commit fails.
  - File(s): `walph.sh` (line 1305)
  - Fix: Use explicit file staging for only the files Walph created: `git add .walph/ specs/ AGENTS.md IMPLEMENTATION_PLAN.md .gitignore`. Remove `2>/dev/null || true` or at minimum log a warning on failure instead of silently ignoring it.

- [ ] **[KISS]** `init.sh` refers to nonexistent `specs/example.md` in the "Next steps" output: In `init.sh` (line 512), the next steps message says `Edit specs/example.md with your requirements`, but the function `create_example_spec()` (lines 205-306) creates `specs/TEMPLATE.md` and `specs/README.md` — there is no `specs/example.md`. Users following these instructions will look for a file that doesn't exist.
  - File(s): `init.sh` (line 512)
  - Fix: Change `Edit specs/example.md` to `Copy specs/TEMPLATE.md → specs/your-feature.md` to match what `walph.sh` `run_init()` outputs at line 1312.

- [ ] **[KISS]** `QUICKSTART.md` line 66 also references `specs/example.md` which doesn't exist: In `QUICKSTART.md` (line 66), the text says "Replace `specs/example.md` with your requirements." However, both `walph.sh init` and `init.sh` create `specs/TEMPLATE.md`, not `specs/example.md`. While the template `templates/specs/example.md` exists in the repo, it's never copied to the project by any init command.
  - File(s): `QUICKSTART.md` (line 66)
  - Fix: Change "Replace `specs/example.md`" to "Copy `specs/TEMPLATE.md` to a new file" or "Replace `specs/TEMPLATE.md`" to match the actual files created by both init paths.

- [ ] **[KISS]** `QUICKSTART.md` references `specs/example.md` in directory structure: In `QUICKSTART.md` (line 295), the directory structure diagram shows `└── example.md          # Your requirements go here` inside the `specs/` directory. However, the init command creates `TEMPLATE.md`, not `example.md`. This reinforces the incorrect expectation set by lines 66 and 512.
  - File(s): `QUICKSTART.md` (line 295)
  - Fix: Change `example.md` to `TEMPLATE.md` in the directory structure diagram.

- [ ] **[ARCHITECTURE]** `QUICKSTART.md` still references `./init.sh` as the command reference instead of `walph init`: In `QUICKSTART.md` (line 307), the command reference section shows `./init.sh <name> --stack <node|python|both> [--docker] [--no-git]` as the initialization command. Since `walph init` is the preferred interface and `init.sh` may be deprecated, this documentation should reference the main entry point.
  - File(s): `QUICKSTART.md` (line 307)
  - Fix: Change `./init.sh <name> --stack <node|python|both> [--docker] [--no-git]` to `walph init <name> --template <type> --stack <lang> [--docker] [--postgres]` to match `walph.sh`'s current options.

- [ ] **[KISS]** `show_gb_howto()` banner box alignment is broken: In `goodbunny.sh` (lines 560-563), the banner box characters are misaligned — the title text `GOOD BUNNY` and subtitle `Autonomous Code Quality Reviewer` don't fill the box width symmetrically, leaving irregular trailing spaces before the right `║` character. This is the same class of cosmetic issue as the `log_iteration_start()` finding but in a different function.
  - File(s): `goodbunny.sh` (lines 560-563)
  - Fix: Calculate the padding dynamically or remove the right-side border character, similar to the fix for `log_iteration_start()`.

## Out of Scope

- **`--dangerously-skip-permissions` in walph.sh and goodbunny.sh build/fix modes**: This is an intentional and documented design decision. The README explicitly warns users about this and recommends isolated environments. Flagging it would be questioning the project's core architecture.
- **`--dangerously-skip-permissions` in Jeeroy Q&A session**: While the previous audit flagged this as Critical, this is actually consistent with the project's design philosophy. The Q&A session needs write access to create spec files. The README's security section already covers the implications of autonomous Claude operation. Downgrading to Out of Scope for consistency with the other tools' usage of the same flag.
- **No tests for the shell scripts themselves**: While testing is a review category, adding a bash testing framework (e.g., bats) would be a significant architectural decision and feature addition, not a code quality fix.
- **Hardcoded Postgres credentials (`postgres:postgres`) in Docker templates**: The README explicitly documents these as development-only defaults, and the templates are scaffolding that users are expected to customize.
- **`docker-compose.yml` using deprecated `version` key**: The `version: '3.8'` key in generated docker-compose files is deprecated in newer Docker Compose versions but still functional and widely used. This is a minor deprecation, not a bug.
- **`echo "$output" | grep` pattern used throughout status_parser.sh and circuit_breaker.sh**: Using `echo "$output" | grep` is not ideal (heredoc or `<<<` would be safer for large outputs), but since these are bash scripts and the pattern is consistent, it's a style preference rather than a bug. Changing all instances would be a refactor, not a fix.
- **Dead code in `lib/utils.sh`**: Functions `ask_choice()`, `file_readable()`, `safe_read_file()`, and `get_project_root()` are defined but never called outside `lib/utils.sh`. These are utility functions that may be intended for future use or external callers. Removing them is a minor cleanup, not a quality fix.
- **Circuit breaker `.goodbunny/state/` exclusion**: Previously flagged as High — the `grep -v` patterns in `check_file_changes()` and `check_commit_activity()` (circuit_breaker.sh lines 60, 100) now correctly exclude both `.walph/state/` and `.goodbunny/state/`. This was fixed in recent commits.
