# Code Review Findings

> Generated by Good Bunny on 2026-02-10 (iteration 3). Run `goodbunny fix` to address findings.

## Summary
- **Project**: Walph Riggum (Autonomous Coding Loop + Jeeroy + Good Bunny)
- **Reviewed**: 2026-02-10
- **Total findings**: 26
- **Critical**: 3 | **High**: 7 | **Medium**: 9 | **Low**: 7

## Critical Findings

- [ ] **[SECURITY]** `--dangerously-skip-permissions` used in Jeeroy Q&A session exposes users to arbitrary command execution: In `jeeroy.sh`, the `run_qa_session()` function (line ~400-403) calls Claude interactively with `--dangerously-skip-permissions`. Unlike the `run_analysis()` (line ~346) and `run_direct_generation()` (line ~440) which use `-p` (print mode, read-only), the Q&A session gives Claude full shell access. A malicious document analyzed by Jeeroy could cause Claude to execute arbitrary commands during the "interactive Q&A" session. Users may not realize the security implications since Q&A mode is described as asking "clarifying questions."
  - File(s): `jeeroy.sh` (lines ~400-403)
  - Fix: Add a prominent warning to the user before launching the Q&A session with `--dangerously-skip-permissions`, and document this in the help text. Consider using `--allowedTools` to restrict to only file writing tools for the specs directory, if Claude CLI supports it.

- [ ] **[SECURITY]** `source "$project_config"` executes arbitrary code from user-controlled config files: Both `lib/config.sh:load_config()` (line ~37) and `goodbunny.sh:load_goodbunny_config()` (line ~142) use `source` to load config files from the project directory. Since `.walph/config` and `.goodbunny/config` are project files that could be committed to a repository, a malicious repository could include config files containing arbitrary shell commands that execute when `walph` or `goodbunny` is run.
  - File(s): `lib/config.sh` (line ~37), `goodbunny.sh` (line ~142)
  - Fix: Instead of `source`-ing the config files, parse them as key-value pairs using a safe reader. For example, read each line, validate it matches `^[A-Z_]+=.*$`, and use `declare` on validated lines only. Alternatively, use `grep` + parameter expansion to extract known config keys.

- [ ] **[SECURITY]** `_relative_path()` in `converter.sh` passes unsanitized file paths into a Python command string: In `lib/converter.sh` (line ~173), the function constructs a Python command with `$target` and `$base` directly interpolated into a `python3 -c` string: `python3 -c "import os; print(os.path.relpath('$target', '$base'))"`. If a filename contains a single quote (e.g., `doc's notes.pdf`), this breaks the Python string and could cause a Python injection. This is reachable via any document directory containing files with single quotes in their names.
  - File(s): `lib/converter.sh` (line ~173)
  - Fix: Pass the paths as arguments to the Python script instead of interpolating them into the code string: `python3 -c "import os, sys; print(os.path.relpath(sys.argv[1], sys.argv[2]))" "$target" "$base"`. This avoids injection entirely.

## High Priority

- [ ] **[ERROR HANDLING]** `check_api_error` has overly broad pattern matching that causes false positives: In `lib/status_parser.sh` (line ~152), the function `check_api_error()` greps for `500|503|overloaded` in the raw Claude output. Since Claude output can contain arbitrary text (including code examples, documentation, or log output that mention "500" or "503"), this will trigger false API error detection on benign output. For example, Claude writing "HTTP status 500 handling" or a log line containing port 5003 would match.
  - File(s): `lib/status_parser.sh` (lines ~149-156)
  - Fix: Make the pattern more specific. Match actual error patterns like `"Error: 500"`, `"HTTP 503"`, `"Internal Server Error"`, or look for specific Claude CLI error message formats. Consider anchoring patterns or matching against only the last ~10 lines of output where real errors appear.

- [ ] **[ERROR HANDLING]** `extract_error_message` matches on any line containing "error" in Claude's entire output: In `lib/status_parser.sh` (line ~164), the function greps for `error|failed|exception` across all of Claude's output. Since Claude produces substantial output including code, explanations, and logs, this function will frequently return false positives -- e.g., a line like "Added error handling to the API" or "All tests passed with no exceptions" would be captured as an error message and fed into the circuit breaker's error pattern matching, potentially causing false same-error-repeated trips.
  - File(s): `lib/status_parser.sh` (lines ~159-168)
  - Fix: Restrict error extraction to the last ~20 lines of output (where actual errors would appear), or only match patterns that indicate actual failures (e.g., lines starting with "Error:" or containing "FAILED" in test output). Consider also looking specifically at Claude's exit code rather than parsing output text.

- [ ] **[DRY]** `run_iteration()` is almost entirely duplicated between `walph.sh` and `goodbunny.sh`: The `run_iteration()` function in `walph.sh` (lines ~1323-1455) and `goodbunny.sh` (lines ~295-447) are ~90% identical. Both create temp files, run Claude with background PID watchdog, handle timeout, check rate limits, check API errors, parse status, update circuit breaker, and check completion. The only differences are the template variable substitutions (goodbunny adds `{{CATEGORIES}}` and `{{FILES}}`).
  - File(s): `walph.sh` (lines ~1323-1455), `goodbunny.sh` (lines ~295-447)
  - Fix: Extract the shared iteration runner logic into a new `lib/runner.sh` library file. The function should accept a callback or additional parameters for tool-specific template substitutions. Both `walph.sh` and `goodbunny.sh` should source and call this shared function.

- [ ] **[DRY]** `main_loop()` is duplicated between `walph.sh` and `goodbunny.sh`: The `main_loop()` function in `walph.sh` (lines ~1457-1516) and `goodbunny.sh` (lines ~453-515) follow the same pattern: iterate up to max, check circuit breaker, select prompt file, select model, run iteration, check completion signal file, increment. The differences are minor (different state directory paths, different model getter functions).
  - File(s): `walph.sh` (lines ~1457-1516), `goodbunny.sh` (lines ~453-515)
  - Fix: Extract into a shared `run_main_loop()` function in `lib/runner.sh` that accepts parameters for the state directory, model getter function, and prompt lookup paths.

- [ ] **[DRY]** `create_agents_md` is defined three times with minor variations: The function exists in `walph.sh` (lines ~456-534 for setup and ~676-933 for init) and `init.sh` (lines ~107-171). All three generate an `AGENTS.md` file with build/test/lint commands based on the stack, but each has a different level of detail and slightly different format.
  - File(s): `walph.sh` (lines ~456-534, ~676-933), `init.sh` (lines ~107-171)
  - Fix: Consolidate into a single `create_agents_md()` function in a shared library (e.g., `lib/project_setup.sh`). Accept parameters for the level of detail needed (basic vs. detailed with structure). Both `walph.sh` and `init.sh` should call this shared function.

- [ ] **[ERROR HANDLING]** `walph.sh` and `goodbunny.sh` lose the exit code from `run_iteration` in the `if/else` pattern: In `walph.sh` (lines ~1489-1498) and `goodbunny.sh` (lines ~489-498), the pattern `if run_iteration ...; then ... else result=$? ...` has a bug. When `run_iteration` fails, `$?` in the `else` branch captures the exit status of the condition test (always `1` for "false"), not the specific exit code from `run_iteration`. This means `result=$?` always gets `1`, and the `if [[ $result -eq 2 ]]` check (intended to detect user-requested exit from rate limit handling) will never trigger. Users who select "exit and resume later" during a rate limit prompt will not actually exit.
  - File(s): `walph.sh` (lines ~1489-1498), `goodbunny.sh` (lines ~489-498)
  - Fix: Capture the exit code before the `if`: `run_iteration "$iteration" "$prompt_file" "$model"; result=$?; if [[ $result -eq 0 ]]; then ... elif [[ $result -eq 2 ]]; then ... else ...`. This preserves the exact exit code from `run_iteration`.

- [ ] **[ERROR HANDLING]** `set -e` combined with `if run_iteration` silently swallows non-zero exits from `run_iteration` sub-commands: Both `walph.sh` and `goodbunny.sh` use `set -euo pipefail`, which causes the script to exit on any unhandled error. However, `run_iteration` is called inside an `if` statement, which disables `set -e` for the entire function body (per bash semantics). This means any command inside `run_iteration` that fails (e.g., `cat "$temp_prompt"`, `wait "$claude_pid"`) will silently continue instead of aborting, potentially masking real errors. Combined with the `$?` capture bug above, error propagation from `run_iteration` is effectively broken.
  - File(s): `walph.sh` (line ~1489), `goodbunny.sh` (line ~489)
  - Fix: Instead of `if run_iteration ...; then`, use `set +e; run_iteration ...; result=$?; set -e; if [[ $result -eq 0 ]]; then ...`. Or restructure to not rely on `set -e` for error handling within `run_iteration`, making all error handling explicit with `|| return` patterns.

## Medium Priority

- [ ] **[COMPLEXITY]** `walph.sh` is a 1595-line monolith combining argument parsing, init, setup, and main loop: The `walph.sh` script handles 6 distinct commands (init, setup, plan, build, status, reset) plus all help text, template generation, Docker file creation, and the main iteration loop. This makes it hard to navigate, test, and maintain.
  - File(s): `walph.sh` (1595 lines)
  - Fix: Extract the `init` command logic (lines ~1086-1317) into a separate file (it already partially exists as `init.sh`). Extract the `setup` command logic (lines ~335-673) into `lib/setup.sh`. Keep `walph.sh` as a thin dispatcher that sources the relevant command module.

- [ ] **[COMPLEXITY]** `create_agents_md()` in `walph.sh` is 257 lines with deep case nesting: The function at lines ~676-933 in `walph.sh` has nested `case` statements (template inside stack) with large heredoc blocks for each combination. This creates a combinatorial explosion that's hard to maintain.
  - File(s): `walph.sh` (lines ~676-933)
  - Fix: Use template files instead of inline heredocs. Create template fragments in `templates/agents/` for each stack and template combination, and assemble them in the function using variable substitution.

- [ ] **[ERROR HANDLING]** Circuit breaker silently does nothing when `jq` is not installed: In `lib/circuit_breaker.sh`, both `_read_state()` (line ~22) and `_update_state()` (line ~35) check for `jq` and silently return empty/nothing if it's missing. The `check_dependencies()` function in `lib/utils.sh` (line ~30) only warns about `jq` but doesn't prevent execution. This means the entire circuit breaker is non-functional without `jq`, but the user gets no indication of this -- the loop will run indefinitely without the safety net.
  - File(s): `lib/circuit_breaker.sh` (lines ~22-45), `lib/utils.sh` (lines ~28-31)
  - Fix: Either make `jq` a required dependency (fail in `check_dependencies()` if missing), or implement a `jq`-free fallback for the circuit breaker state file (e.g., using `grep`/`sed` to parse the simple JSON structure, or switching to a plain key-value format).

- [ ] **[ERROR HANDLING]** `parse_args` in `walph.sh` and `goodbunny.sh` don't validate `--max-iterations` or `--model` arguments: At lines ~84-89 in `walph.sh` and lines ~84-98 in `goodbunny.sh`, `--max-iterations` does `shift 2` without checking if `$2` exists or is a number. Running `walph build --max-iterations` (without a value) will cause an unbound variable error or silently use the next argument as the number. Same issue with `--model`, `--categories`, and `--files` in `goodbunny.sh`.
  - File(s): `walph.sh` (lines ~84-89), `goodbunny.sh` (lines ~84-98)
  - Fix: Add validation before `shift 2`: check that `$#` is >= 2, and for `--max-iterations`, validate that `$2` is a positive integer. Show a helpful error message if validation fails. Jeeroy already does this correctly (e.g., line ~145: `if [[ $# -lt 2 ]]; then log_error ...`).

- [ ] **[ARCHITECTURE]** `init.sh` is a standalone duplicate of functionality already in `walph.sh init`: The `init.sh` script (519 lines) provides project initialization, but `walph.sh` also implements a full `init` command (lines ~51-56, ~122-175, ~1086-1317) with more features (templates, docker, postgres flags). The `install.sh` script installs a `walph-init` wrapper pointing to `init.sh`, but `walph init` already works. Users may not know which to use.
  - File(s): `init.sh` (entire file), `walph.sh` (init-related sections)
  - Fix: Deprecate `init.sh` in favor of `walph.sh init` which has more features. Update `install.sh` to remove the `walph-init` wrapper, or make it call `walph init` instead of `init.sh`.

- [ ] **[ERROR HANDLING]** Temp files in `walph.sh` and `goodbunny.sh` `run_iteration()` may leak on unexpected exit: In both `walph.sh` (lines ~1362-1367) and `goodbunny.sh` (lines ~357-362), temp files are created with `mktemp` but are only cleaned up in the happy path with `rm -f`. If the script is interrupted (SIGINT/SIGTERM) between temp file creation and cleanup, the temp files will remain on disk. Unlike `jeeroy.sh` which has a proper `trap cleanup_temp_files EXIT INT TERM` pattern (lines ~27-45), the other scripts don't trap for temp file cleanup.
  - File(s): `walph.sh` (lines ~1362-1407), `goodbunny.sh` (lines ~357-399)
  - Fix: Add a trap-based cleanup mechanism similar to `jeeroy.sh` (lines ~27-45). Track temp files in a global variable and register a trap to clean them up on EXIT/INT/TERM.

- [ ] **[KISS]** `install.sh` doesn't install `goodbunny` wrapper: The `install.sh` script (lines ~72-101) creates wrapper scripts for `walph`, `walph-init`, and `jeeroy`, but not for `goodbunny`. Similarly, `uninstall.sh` doesn't remove a `goodbunny` wrapper. This means `goodbunny` can't be used as a global command after installation.
  - File(s): `install.sh` (lines ~72-101), `uninstall.sh` (lines ~12-22)
  - Fix: Add a `goodbunny` wrapper creation block in `install.sh` (similar to the jeeroy wrapper at lines ~93-101), and add removal of `goodbunny` in `uninstall.sh`.

- [ ] **[ERROR HANDLING]** `check_commit_activity()` may fail on the first iteration due to empty `last_git_hash`: In `lib/circuit_breaker.sh`, `init_circuit_breaker()` (line ~17) initializes `last_git_hash` to `""` (empty string). On the very first iteration, `check_commit_activity()` (lines ~91-110) calls `git diff --name-only "$last_hash" "$current_hash"` where `$last_hash` is empty. This produces a git error, and the function falls through to `return 1` (no commit), causing `no_commit_count` to increment incorrectly on the first iteration even though no commit was expected yet.
  - File(s): `lib/circuit_breaker.sh` (lines ~17, ~91-110)
  - Fix: In `init_circuit_breaker()`, initialize `last_git_hash` to the current `HEAD` hash instead of an empty string: replace the empty `""` with `$(git rev-parse HEAD 2>/dev/null || echo "no-git")`. Alternatively, add a guard in `check_commit_activity()` to handle the empty-hash case by skipping the diff.

- [ ] **[ARCHITECTURE]** `PROMPT_build.md` and `PROMPT_fix.md` instruct Claude to use `git add -A` which may stage unintended files: Both prompt templates instruct the autonomous Claude agent to use `git add -A` when committing (PROMPT_build.md line ~151, PROMPT_fix.md line ~76). `git add -A` stages all changes in the working directory, including files that may have been created unintentionally (temp files, debug logs, core dumps, etc.). This is particularly risky given that Claude runs with `--dangerously-skip-permissions` and could create files anywhere in the repo.
  - File(s): `templates/PROMPT_build.md` (line ~151), `templates/PROMPT_fix.md` (line ~76)
  - Fix: Change the prompt instructions to use `git add <specific files>` instead. Instruct Claude to explicitly list the files it changed and stage only those, or at minimum use `git add .` (stages from current directory, not entire repo).

## Low Priority

- [ ] **[DRY]** Docker file creation logic is duplicated between `walph.sh` and `init.sh`: Both `walph.sh:create_docker_files()` (lines ~936-1033) and `init.sh:create_docker_setup()` (lines ~309-393) create Docker configurations with slightly different formats and options.
  - File(s): `walph.sh` (lines ~936-1033), `init.sh` (lines ~309-393)
  - Fix: Consolidate into a shared function in a library file (e.g., `lib/docker.sh`) or use the template files that already exist in `templates/docker/`.

- [ ] **[DRY]** `.gitignore` creation logic is duplicated between `walph.sh` and `init.sh`: Both `walph.sh:run_init()` (lines ~1263-1294) and `init.sh:create_gitignore()` (lines ~396-441) create `.gitignore` files with slightly different contents (init.sh's version is more comprehensive, including coverage/ and .pytest_cache/).
  - File(s): `walph.sh` (lines ~1263-1294), `init.sh` (lines ~396-441)
  - Fix: Use a shared `.gitignore` template file in `templates/` and have both scripts copy from it.

- [ ] **[COMPLEXITY]** `_relative_path()` in `converter.sh` shells out to Python as a fallback: In `lib/converter.sh` (lines ~162-178), the `_relative_path()` function tries `realpath --relative-to`, then falls back to `python3 -c "..."`, then to `basename`. The Python fallback is a heavyweight solution for a simple path operation and introduces a dependency on Python being installed.
  - File(s): `lib/converter.sh` (lines ~162-178)
  - Fix: Implement a pure-bash relative path function, or simply use `basename` consistently since the relative paths are only used for display labels in source markers, not for functional purposes.

- [ ] **[ARCHITECTURE]** `show_howto()` and `show_help()` in `lib/utils.sh` are Walph-specific but live in a shared library: The `show_howto()` (lines ~249-381) and `show_help()` (lines ~383-436) functions in `lib/utils.sh` contain Walph-specific content. Since `lib/utils.sh` is sourced by all three tools (walph, goodbunny, jeeroy), these Walph-specific functions pollute the namespace when running goodbunny or jeeroy.
  - File(s): `lib/utils.sh` (lines ~249-436)
  - Fix: Move `show_howto()`, `show_help()`, and `show_version()` out of `lib/utils.sh` and into `walph.sh` directly, or into a dedicated `lib/walph_help.sh` that only `walph.sh` sources.

- [ ] **[KISS]** `log_iteration_start()` banner has hardcoded padding that breaks alignment with long iteration numbers: In `lib/logging.sh` (lines ~98-107), the banner uses fixed padding after the iteration info text. When `iteration` or `max_iterations` are multi-digit (e.g., "Iteration 15 / 100"), the right edge of the box misaligns. This is cosmetic but looks broken.
  - File(s): `lib/logging.sh` (lines ~98-107)
  - Fix: Either remove the right-side border character, or calculate padding dynamically based on the length of the iteration string using `printf` formatting.

- [ ] **[KISS]** `QUICKSTART.md` references `ralph_*.log` but actual log files use `walph_` prefix: In `QUICKSTART.md` (line ~279), the command `cat .walph/logs/ralph_*.log | tail -100` references files starting with `ralph_`, but the actual logging in `lib/logging.sh` (line ~42) uses `${LOG_FILE_PREFIX:-walph}_${session_id}.log`, which defaults to `walph_*`. Users following the quickstart guide would see no matching files.
  - File(s): `QUICKSTART.md` (line ~279)
  - Fix: Change `ralph_*.log` to `walph_*.log` in the troubleshooting command.

- [ ] **[KISS]** `QUICKSTART.md` references `ralph_*.log` in a second location: In `QUICKSTART.md` (line ~250), the monitoring command `tail -f .walph/logs/ralph_*.log` also uses the incorrect `ralph_` prefix.
  - File(s): `QUICKSTART.md` (line ~250)
  - Fix: Change `ralph_*.log` to `walph_*.log` in the monitoring command as well.

## Out of Scope

- **`--dangerously-skip-permissions` in walph.sh and goodbunny.sh build/fix modes**: This is an intentional and documented design decision. The README explicitly warns users about this and recommends isolated environments. Flagging it would be questioning the project's core architecture.
- **No tests for the shell scripts themselves**: While testing is a review category, adding a bash testing framework (e.g., bats) would be a significant architectural decision and feature addition, not a code quality fix.
- **Hardcoded Postgres credentials (`postgres:postgres`) in Docker templates**: The README explicitly documents these as development-only defaults, and the templates are scaffolding that users are expected to customize.
- **`docker-compose.yml` using deprecated `version` key**: The `version: '3.8'` key in generated docker-compose files is deprecated in newer Docker Compose versions but still functional and widely used. This is a minor deprecation, not a bug.
- **`echo "$output" | grep` pattern used throughout status_parser.sh and circuit_breaker.sh**: Using `echo "$output" | grep` is not ideal (heredoc or `<<<` would be safer for large outputs), but since these are bash scripts and the pattern is consistent, it's a style preference rather than a bug. Changing all instances would be a refactor, not a fix.
