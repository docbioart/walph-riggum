# Code Review Findings

> Generated by Good Bunny on 2026-02-10 (iteration 6 — final). Run `goodbunny fix` to address findings.

## Summary
- **Project**: Walph Riggum (Autonomous Coding Loop + Jeeroy + Good Bunny)
- **Reviewed**: 2026-02-10
- **Total findings**: 36
- **Critical**: 3 | **High**: 10 | **Medium**: 12 | **Low**: 11

## Critical Findings

- [ ] **[SECURITY]** `--dangerously-skip-permissions` used in Jeeroy Q&A session exposes users to arbitrary command execution: In `jeeroy.sh`, the `run_qa_session()` function (line ~374-407) calls Claude interactively with `--dangerously-skip-permissions` (line 402). Unlike `run_analysis()` (line ~326) and `run_direct_generation()` (line ~413) which use `-p` (print mode, read-only), the Q&A session gives Claude full shell access. A malicious document analyzed by Jeeroy could cause Claude to execute arbitrary commands during the "interactive Q&A" session. Users may not realize the security implications since Q&A mode is described as asking "clarifying questions."
  - File(s): `jeeroy.sh` (lines ~374-407, specifically line 402)
  - Fix: Add a prominent warning to the user before launching the Q&A session with `--dangerously-skip-permissions`, and document this in the help text. Consider using `--allowedTools` to restrict to only file writing tools for the specs directory, if Claude CLI supports it.

- [ ] **[SECURITY]** `source "$project_config"` executes arbitrary code from user-controlled config files: Both `lib/config.sh:load_config()` (line 38) and `goodbunny.sh:load_goodbunny_config()` (line 142) use `source` to load config files from the project directory. Since `.walph/config` and `.goodbunny/config` are project files that could be committed to a repository, a malicious repository could include config files containing arbitrary shell commands that execute when `walph` or `goodbunny` is run.
  - File(s): `lib/config.sh` (line 38), `goodbunny.sh` (line 142)
  - Fix: Instead of `source`-ing the config files, parse them as key-value pairs using a safe reader. For example, read each line, validate it matches `^[A-Z_]+=.*$`, and use `declare` on validated lines only. Alternatively, use `grep` + parameter expansion to extract known config keys.

- [ ] **[SECURITY]** `_relative_path()` in `converter.sh` passes unsanitized file paths into a Python command string: In `lib/converter.sh` (line 173), the function constructs a Python command with `$target` and `$base` directly interpolated into a `python3 -c` string: `python3 -c "import os; print(os.path.relpath('$target', '$base'))"`. If a filename contains a single quote (e.g., `doc's notes.pdf`), this breaks the Python string and could cause a Python injection. This is reachable via any document directory containing files with single quotes in their names.
  - File(s): `lib/converter.sh` (line 173)
  - Fix: Pass the paths as arguments to the Python script instead of interpolating them into the code string: `python3 -c "import os, sys; print(os.path.relpath(sys.argv[1], sys.argv[2]))" "$target" "$base"`. This avoids injection entirely.

## High Priority

- [ ] **[ERROR HANDLING]** `check_api_error` has overly broad pattern matching that causes false positives: In `lib/status_parser.sh` (line 152), the function `check_api_error()` greps for `500|503|overloaded` in the raw Claude output. Since Claude output can contain arbitrary text (including code examples, documentation, or log output that mention "500" or "503"), this will trigger false API error detection on benign output. For example, Claude writing "HTTP status 500 handling" or a log line containing port 5003 would match.
  - File(s): `lib/status_parser.sh` (lines 149-156)
  - Fix: Make the pattern more specific. Match actual error patterns like `"Error: 500"`, `"HTTP 503"`, `"Internal Server Error"`, or look for specific Claude CLI error message formats. Consider anchoring patterns or matching against only the last ~10 lines of output where real errors appear.

- [ ] **[ERROR HANDLING]** `extract_error_message` matches on any line containing "error" in Claude's entire output: In `lib/status_parser.sh` (line 164), the function greps for `error|failed|exception` across all of Claude's output. Since Claude produces substantial output including code, explanations, and logs, this function will frequently return false positives -- e.g., a line like "Added error handling to the API" or "All tests passed with no exceptions" would be captured as an error message and fed into the circuit breaker's error pattern matching, potentially causing false same-error-repeated trips.
  - File(s): `lib/status_parser.sh` (lines 159-169)
  - Fix: Restrict error extraction to the last ~20 lines of output (where actual errors would appear), or only match patterns that indicate actual failures (e.g., lines starting with "Error:" or containing "FAILED" in test output). Consider also looking specifically at Claude's exit code rather than parsing output text.

- [ ] **[DRY]** `run_iteration()` is almost entirely duplicated between `walph.sh` and `goodbunny.sh`: The `run_iteration()` function in `walph.sh` (lines 1323-1455) and `goodbunny.sh` (lines 295-447) are ~90% identical. Both create temp files, run Claude with background PID watchdog, handle timeout, check rate limits, check API errors, parse status, update circuit breaker, and check completion. The only differences are the template variable substitutions (goodbunny adds `{{CATEGORIES}}` and `{{FILES}}`).
  - File(s): `walph.sh` (lines 1323-1455), `goodbunny.sh` (lines 295-447)
  - Fix: Extract the shared iteration runner logic into a new `lib/runner.sh` library file. The function should accept a callback or additional parameters for tool-specific template substitutions. Both `walph.sh` and `goodbunny.sh` should source and call this shared function.

- [ ] **[DRY]** `main_loop()` is duplicated between `walph.sh` and `goodbunny.sh`: The `main_loop()` function in `walph.sh` (lines 1457-1516) and `goodbunny.sh` (lines 453-515) follow the same pattern: iterate up to max, check circuit breaker, select prompt file, select model, run iteration, check completion signal file, increment. The differences are minor (different state directory paths, different model getter functions).
  - File(s): `walph.sh` (lines 1457-1516), `goodbunny.sh` (lines 453-515)
  - Fix: Extract into a shared `run_main_loop()` function in `lib/runner.sh` that accepts parameters for the state directory, model getter function, and prompt lookup paths.

- [ ] **[DRY]** `create_agents_md` is defined three times with minor variations: The function exists in `walph.sh` (lines 456-534 for setup and 676-933 for init) and `init.sh` (lines 107-171). All three generate an `AGENTS.md` file with build/test/lint commands based on the stack, but each has a different level of detail and slightly different format.
  - File(s): `walph.sh` (lines 456-534, 676-933), `init.sh` (lines 107-171)
  - Fix: Consolidate into a single `create_agents_md()` function in a shared library (e.g., `lib/project_setup.sh`). Accept parameters for the level of detail needed (basic vs. detailed with structure). Both `walph.sh` and `init.sh` should call this shared function.

- [ ] **[ERROR HANDLING]** `walph.sh` and `goodbunny.sh` lose the exit code from `run_iteration` in the `if/else` pattern: In `walph.sh` (lines 1489-1498) and `goodbunny.sh` (lines 489-498), the pattern `if run_iteration ...; then ... else result=$? ...` has a bug. When `run_iteration` fails, `$?` in the `else` branch captures the exit status of the condition test (always `1` for "false"), not the specific exit code from `run_iteration`. This means `result=$?` always gets `1`, and the `if [[ $result -eq 2 ]]` check (intended to detect user-requested exit from rate limit handling) will never trigger. Users who select "exit and resume later" during a rate limit prompt will not actually exit.
  - File(s): `walph.sh` (lines 1489-1498), `goodbunny.sh` (lines 489-498)
  - Fix: Capture the exit code before the `if`: `run_iteration "$iteration" "$prompt_file" "$model"; result=$?; if [[ $result -eq 0 ]]; then ... elif [[ $result -eq 2 ]]; then ... else ...`. This preserves the exact exit code from `run_iteration`.

- [ ] **[ERROR HANDLING]** `set -e` combined with `if run_iteration` silently swallows non-zero exits from `run_iteration` sub-commands: Both `walph.sh` and `goodbunny.sh` use `set -euo pipefail`, which causes the script to exit on any unhandled error. However, `run_iteration` is called inside an `if` statement, which disables `set -e` for the entire function body (per bash semantics). This means any command inside `run_iteration` that fails (e.g., `cat "$temp_prompt"`, `wait "$claude_pid"`) will silently continue instead of aborting, potentially masking real errors. Combined with the `$?` capture bug above, error propagation from `run_iteration` is effectively broken.
  - File(s): `walph.sh` (line 1489), `goodbunny.sh` (line 489)
  - Fix: Instead of `if run_iteration ...; then`, use `set +e; run_iteration ...; result=$?; set -e; if [[ $result -eq 0 ]]; then ...`. Or restructure to not rely on `set -e` for error handling within `run_iteration`, making all error handling explicit with `|| return` patterns.

- [ ] **[ERROR HANDLING]** `goodbunny.sh` circuit breaker thresholds silently inherit `lib/config.sh` defaults instead of goodbunny defaults: When `goodbunny.sh` sources `lib/config.sh` (line 21), `config.sh` sets `CIRCUIT_BREAKER_NO_CHANGE_THRESHOLD=3`, `CIRCUIT_BREAKER_SAME_ERROR_THRESHOLD=5`, and `CIRCUIT_BREAKER_NO_COMMIT_THRESHOLD=5` at file scope (config.sh lines 16-18). Later, `load_goodbunny_config()` (goodbunny.sh line 152-154) uses `${CIRCUIT_BREAKER_NO_CHANGE_THRESHOLD:-$GB_DEFAULT_CB_NO_CHANGE}` to set thresholds. Since the variables are already set by config.sh, the `:-` default expansion never triggers, and the goodbunny-specific defaults (`3/3/4`) are silently ignored for `SAME_ERROR` and `NO_COMMIT` — they keep the walph defaults of `5/5`. Only `NO_CHANGE` matches by coincidence (both are `3`).
  - File(s): `goodbunny.sh` (lines 152-154), `lib/config.sh` (lines 16-18)
  - Fix: In `load_goodbunny_config()`, unconditionally set the goodbunny-specific thresholds before the conditional override: `CIRCUIT_BREAKER_SAME_ERROR_THRESHOLD="${GOODBUNNY_CB_SAME_ERROR:-$GB_DEFAULT_CB_SAME_ERROR}"` (bypassing any previously set value). Or, change `lib/config.sh` to not set these at file scope — only set them inside `load_config()`.

- [ ] **[ERROR HANDLING]** `check_file_changes()` in `circuit_breaker.sh` only excludes `.walph/state/` but not `.goodbunny/state/`: In `lib/circuit_breaker.sh` (line 60), `check_file_changes()` uses `grep -v '\.walph/state/'` to exclude Walph state files from the working-directory change detection. However, when running under Good Bunny, the circuit breaker state file is at `.goodbunny/state/circuit_breaker.json`, which is NOT excluded. This means every iteration that updates the circuit breaker state file will count as a "file change", preventing the "no file changes" circuit breaker from ever triggering during `goodbunny fix` runs. The safety net for detecting stuck-with-no-progress is effectively disabled for Good Bunny.
  - File(s): `lib/circuit_breaker.sh` (line 60)
  - Fix: Change the `grep -v` pattern to exclude both state directories: `grep -v '\.walph/state/\|\.goodbunny/state/'`. Or generalize it to exclude the state directory path from a variable (e.g., `$STATE_DIR_PATTERN`) that each tool sets.

- [ ] **[SECURITY]** `sed` variable substitution in `run_iteration()` is vulnerable to injection via prompt content: In both `walph.sh` (lines 1342-1344) and `goodbunny.sh` (lines 313-315), template variables are substituted using `echo "$full_prompt" | sed "s/{{ITERATION}}/$iteration/g"`. The `$iteration` variable is numeric and safe, but in `goodbunny.sh` (lines 322-329), the `$categories_section` and `$files_section` are derived from user-provided `--categories` and `--files` arguments. Although there's an attempt to escape sed special chars with `sed 's/[&/\]/\\&/g'`, the backslash escaping in the character class `[&/\]` is itself problematic — the closing `\]` may be parsed as an escaped bracket on some sed implementations. More importantly, if the user passes `--files` or `--categories` values containing newlines or other special characters, the substitution can produce corrupted prompts or inject unintended content.
  - File(s): `goodbunny.sh` (lines 322-329)
  - Fix: Use a different substitution approach that avoids `sed` entirely. For example, use bash parameter expansion: `full_prompt="${full_prompt//\{\{CATEGORIES\}\}/$categories_section}"`. This handles arbitrary replacement content safely without needing to escape sed metacharacters.

## Medium Priority

- [ ] **[COMPLEXITY]** `walph.sh` is a 1595-line monolith combining argument parsing, init, setup, and main loop: The `walph.sh` script handles 6 distinct commands (init, setup, plan, build, status, reset) plus all help text, template generation, Docker file creation, and the main iteration loop. This makes it hard to navigate, test, and maintain.
  - File(s): `walph.sh` (1595 lines)
  - Fix: Extract the `init` command logic (lines 1086-1317) into a separate file (it already partially exists as `init.sh`). Extract the `setup` command logic (lines 335-673) into `lib/setup.sh`. Keep `walph.sh` as a thin dispatcher that sources the relevant command module.

- [ ] **[COMPLEXITY]** `create_agents_md()` in `walph.sh` is 257 lines with deep case nesting: The function at lines 676-933 in `walph.sh` has nested `case` statements (template inside stack) with large heredoc blocks for each combination. This creates a combinatorial explosion that's hard to maintain.
  - File(s): `walph.sh` (lines 676-933)
  - Fix: Use template files instead of inline heredocs. Create template fragments in `templates/agents/` for each stack and template combination, and assemble them in the function using variable substitution.

- [ ] **[ERROR HANDLING]** Circuit breaker silently does nothing when `jq` is not installed: In `lib/circuit_breaker.sh`, both `_read_state()` (line 22) and `_update_state()` (line 30) check for `jq` and silently return empty/nothing if it's missing. The `check_dependencies()` function in `lib/utils.sh` (line 30) only warns about `jq` but doesn't prevent execution. This means the entire circuit breaker is non-functional without `jq`, but the user gets no indication of this — the loop will run indefinitely without the safety net.
  - File(s): `lib/circuit_breaker.sh` (lines 22-45), `lib/utils.sh` (lines 28-31)
  - Fix: Either make `jq` a required dependency (fail in `check_dependencies()` if missing), or implement a `jq`-free fallback for the circuit breaker state file (e.g., using `grep`/`sed` to parse the simple JSON structure, or switching to a plain key-value format).

- [ ] **[ERROR HANDLING]** `parse_args` in `walph.sh` and `goodbunny.sh` don't validate `--max-iterations` or `--model` arguments: At lines 84-89 in `walph.sh` and lines 84-98 in `goodbunny.sh`, `--max-iterations` does `shift 2` without checking if `$2` exists or is a number. Running `walph build --max-iterations` (without a value) will cause an unbound variable error or silently use the next argument as the number. Same issue with `--model`, `--categories`, and `--files` in `goodbunny.sh`.
  - File(s): `walph.sh` (lines 84-89), `goodbunny.sh` (lines 84-98)
  - Fix: Add validation before `shift 2`: check that `$#` is >= 2, and for `--max-iterations`, validate that `$2` is a positive integer. Show a helpful error message if validation fails. Jeeroy already does this correctly (e.g., jeeroy.sh line 145: `if [[ $# -lt 2 ]]; then log_error ...`).

- [ ] **[ARCHITECTURE]** `init.sh` is a standalone duplicate of functionality already in `walph.sh init`: The `init.sh` script (519 lines) provides project initialization, but `walph.sh` also implements a full `init` command (lines 51-56, 122-175, 1086-1317) with more features (templates, docker, postgres flags). The `install.sh` script installs a `walph-init` wrapper pointing to `init.sh`, but `walph init` already works. Users may not know which to use.
  - File(s): `init.sh` (entire file), `walph.sh` (init-related sections)
  - Fix: Deprecate `init.sh` in favor of `walph.sh init` which has more features. Update `install.sh` to remove the `walph-init` wrapper, or make it call `walph init` instead of `init.sh`.

- [ ] **[ERROR HANDLING]** Temp files in `walph.sh` and `goodbunny.sh` `run_iteration()` may leak on unexpected exit: In both `walph.sh` (lines 1362-1407) and `goodbunny.sh` (lines 357-399), temp files are created with `mktemp` but are only cleaned up in the happy path with `rm -f`. If the script is interrupted (SIGINT/SIGTERM) between temp file creation and cleanup, the temp files will remain on disk. Unlike `jeeroy.sh` which has a proper `trap cleanup_temp_files EXIT INT TERM` pattern (lines 27-45), the other scripts don't trap for temp file cleanup.
  - File(s): `walph.sh` (lines 1362-1407), `goodbunny.sh` (lines 357-399)
  - Fix: Add a trap-based cleanup mechanism similar to `jeeroy.sh` (lines 27-45). Track temp files in a global variable and register a trap to clean them up on EXIT/INT/TERM.

- [ ] **[KISS]** `install.sh` doesn't install `goodbunny` wrapper: The `install.sh` script (lines 72-101) creates wrapper scripts for `walph`, `walph-init`, and `jeeroy`, but not for `goodbunny`. Similarly, `uninstall.sh` doesn't remove a `goodbunny` wrapper. This means `goodbunny` can't be used as a global command after installation.
  - File(s): `install.sh` (lines 72-101), `uninstall.sh` (lines 12-26)
  - Fix: Add a `goodbunny` wrapper creation block in `install.sh` (similar to the jeeroy wrapper at lines 93-101), and add removal of `goodbunny` in `uninstall.sh`.

- [ ] **[ERROR HANDLING]** `check_commit_activity()` may fail on the first iteration due to empty `last_git_hash`: In `lib/circuit_breaker.sh`, `init_circuit_breaker()` (line 17) initializes `last_git_hash` to `""` (empty string). On the very first iteration, `check_commit_activity()` (lines 91-110) calls `git diff --name-only "$last_hash" "$current_hash"` where `$last_hash` is empty. This produces a git error, and the function falls through to `return 1` (no commit), causing `no_commit_count` to increment incorrectly on the first iteration even though no commit was expected yet.
  - File(s): `lib/circuit_breaker.sh` (lines 17, 91-110)
  - Fix: In `init_circuit_breaker()`, initialize `last_git_hash` to the current `HEAD` hash instead of an empty string: replace the empty `""` with `$(git rev-parse HEAD 2>/dev/null || echo "no-git")`. Alternatively, add a guard in `check_commit_activity()` to handle the empty-hash case by skipping the diff.

- [ ] **[ARCHITECTURE]** `PROMPT_build.md` and `PROMPT_fix.md` instruct Claude to use `git add -A` which may stage unintended files: Both prompt templates instruct the autonomous Claude agent to use `git add -A` when committing (PROMPT_build.md line 151, PROMPT_fix.md line 76). `git add -A` stages all changes in the working directory, including files that may have been created unintentionally (temp files, debug logs, core dumps, etc.). This is particularly risky given that Claude runs with `--dangerously-skip-permissions` and could create files anywhere in the repo.
  - File(s): `templates/PROMPT_build.md` (line 151), `templates/PROMPT_fix.md` (line 76)
  - Fix: Change the prompt instructions to use `git add <specific files>` instead. Instruct Claude to explicitly list the files it changed and stage only those, or at minimum use `git add .` (stages from current directory, not entire repo).

- [ ] **[ERROR HANDLING]** `_update_state()` in `circuit_breaker.sh` leaks temp file on `jq` failure: In `lib/circuit_breaker.sh` (lines 36-43), `_update_state()` creates a temp file with `mktemp` (line 37), pipes `jq` output to it, then `mv`s it into place. If `jq` fails (e.g., malformed JSON in state file), the `&&` prevents the `mv`, but the temp file from `mktemp` is never cleaned up. Over many iterations with a corrupted state file, this accumulates orphaned temp files in `/tmp`.
  - File(s): `lib/circuit_breaker.sh` (lines 36-43)
  - Fix: Add a trap or explicit cleanup: `jq ... > "$tmp_file" && mv "$tmp_file" "$CIRCUIT_BREAKER_STATE_FILE" || rm -f "$tmp_file"`.

- [ ] **[KISS]** `completion_signal` file check is dead code — never written, only read: In both `walph.sh` (lines 1502-1505) and `goodbunny.sh` (lines 501-504), `main_loop()` checks for a `completion_signal` file in the state directory as a secondary completion detection mechanism. However, no code anywhere in the project ever creates this file. Completion is actually detected via the `check_completion()` return value in `run_iteration()`. This dead code path adds confusion about how completion works.
  - File(s): `walph.sh` (lines 1502-1505), `goodbunny.sh` (lines 501-504)
  - Fix: Remove the `completion_signal` file check from both `main_loop()` functions since it can never trigger. If the intent is to have a file-based completion mechanism, add code to `run_iteration()` to touch the file when `check_completion()` returns 0, and document the design in a comment.

- [ ] **[ERROR HANDLING]** `run_analysis()` and `run_direct_generation()` in `jeeroy.sh` use `cat | claude` piping pattern that loses Claude CLI exit code on pipe failure: In `jeeroy.sh` (lines 346-348 and 440-442), both functions pipe the temp file to Claude via `cat "$temp_prompt" | claude -p ...`. With `set -o pipefail`, if `cat` fails (e.g., file was deleted), the pipe would propagate the error. However, the `if cat ... | claude ...; then` pattern disables `set -e` inside the conditional, meaning a `cat` failure will silently produce an empty stdin for Claude, and Claude will proceed with no input. The resulting empty output will then be treated as a valid analysis result.
  - File(s): `jeeroy.sh` (lines 346-348, 440-442)
  - Fix: Use input redirection instead of cat-pipe: `claude -p --model "$MODEL" < "$temp_prompt" > "$temp_output" 2>&1`. This is how `walph.sh` and `goodbunny.sh` already do it (e.g., walph.sh line 1375). It eliminates the UUOC and the pipe failure edge case.

## Low Priority

- [ ] **[DRY]** Docker file creation logic is duplicated between `walph.sh` and `init.sh`: Both `walph.sh:create_docker_files()` (lines 936-1033) and `init.sh:create_docker_setup()` (lines 309-393) create Docker configurations with slightly different formats and options.
  - File(s): `walph.sh` (lines 936-1033), `init.sh` (lines 309-393)
  - Fix: Consolidate into a shared function in a library file (e.g., `lib/docker.sh`) or use the template files that already exist in `templates/docker/`.

- [ ] **[DRY]** `.gitignore` creation logic is duplicated between `walph.sh` and `init.sh`: Both `walph.sh:run_init()` (lines 1263-1294) and `init.sh:create_gitignore()` (lines 396-441) create `.gitignore` files with slightly different contents (init.sh's version is more comprehensive, including coverage/ and .pytest_cache/).
  - File(s): `walph.sh` (lines 1263-1294), `init.sh` (lines 396-441)
  - Fix: Use a shared `.gitignore` template file in `templates/` and have both scripts copy from it.

- [ ] **[COMPLEXITY]** `_relative_path()` in `converter.sh` shells out to Python as a fallback: In `lib/converter.sh` (lines 162-178), the `_relative_path()` function tries `realpath --relative-to`, then falls back to `python3 -c "..."`, then to `basename`. The Python fallback is a heavyweight solution for a simple path operation and introduces a dependency on Python being installed.
  - File(s): `lib/converter.sh` (lines 162-178)
  - Fix: Implement a pure-bash relative path function, or simply use `basename` consistently since the relative paths are only used for display labels in source markers, not for functional purposes.

- [ ] **[ARCHITECTURE]** `show_howto()` and `show_help()` in `lib/utils.sh` are Walph-specific but live in a shared library: The `show_howto()` (lines 249-381) and `show_help()` (lines 383-436) functions in `lib/utils.sh` contain Walph-specific content. Since `lib/utils.sh` is sourced by all three tools (walph, goodbunny, jeeroy), these Walph-specific functions pollute the namespace when running goodbunny or jeeroy.
  - File(s): `lib/utils.sh` (lines 249-436)
  - Fix: Move `show_howto()`, `show_help()`, and `show_version()` out of `lib/utils.sh` and into `walph.sh` directly, or into a dedicated `lib/walph_help.sh` that only `walph.sh` sources.

- [ ] **[KISS]** `log_iteration_start()` banner has hardcoded padding that breaks alignment with long iteration numbers: In `lib/logging.sh` (lines 98-107), the banner uses fixed padding after the iteration info text. When `iteration` or `max_iterations` are multi-digit (e.g., "Iteration 15 / 100"), the right edge of the box misaligns. This is cosmetic but looks broken.
  - File(s): `lib/logging.sh` (lines 98-107)
  - Fix: Either remove the right-side border character, or calculate padding dynamically based on the length of the iteration string using `printf` formatting.

- [ ] **[KISS]** `QUICKSTART.md` references `ralph_*.log` but actual log files use `walph_` prefix: In `QUICKSTART.md` (line 279), the command `cat .walph/logs/ralph_*.log | tail -100` references files starting with `ralph_`, but the actual logging in `lib/logging.sh` (line 42) uses `${LOG_FILE_PREFIX:-walph}_${session_id}.log`, which defaults to `walph_*`. Users following the quickstart guide would see no matching files.
  - File(s): `QUICKSTART.md` (line 279)
  - Fix: Change `ralph_*.log` to `walph_*.log` in the troubleshooting command.

- [ ] **[KISS]** `QUICKSTART.md` references `ralph_*.log` in a second location: In `QUICKSTART.md` (line 250), the monitoring command `tail -f .walph/logs/ralph_*.log` also uses the incorrect `ralph_` prefix.
  - File(s): `QUICKSTART.md` (line 250)
  - Fix: Change `ralph_*.log` to `walph_*.log` in the monitoring command as well.

- [ ] **[ERROR HANDLING]** `init.sh` `parse_args` doesn't validate `--stack` argument: In `init.sh` (lines 60-62), `--stack` does `shift 2` without checking if `$2` exists. Running `./init.sh my-project --stack` (without a value) will cause an unbound variable error with `set -u` or a confusing error. This is the same class of bug as the walph.sh/goodbunny.sh argument validation issue, but in a different script.
  - File(s): `init.sh` (lines 60-62)
  - Fix: Add a check before `shift 2`: `if [[ $# -lt 2 ]]; then log_error "--stack requires a type argument"; exit 1; fi`. Jeeroy already does this correctly.

- [ ] **[KISS]** `jeeroy.sh` writes `.jeeroy_context.md` to the project directory but doesn't add it to `.gitignore`: In `jeeroy.sh` (line 387), `run_qa_session()` writes a context file to `$PROJECT_DIR/.jeeroy_context.md`. While the file is cleaned up at line 406 with `rm -f`, if the script is interrupted (e.g., Ctrl+C during the interactive Q&A session, before line 406 runs), this file will remain in the project directory and could be accidentally committed. The trap at line 37 only cleans up tracked temp files via `$JEEROY_TEMP_FILES`, but `.jeeroy_context.md` is not tracked in that variable.
  - File(s): `jeeroy.sh` (lines 387, 406)
  - Fix: Either add `.jeeroy_context.md` to the `$JEEROY_TEMP_FILES` tracking variable so it's cleaned up by the EXIT trap, or use `make_temp()` to create the context file in `/tmp/` instead of in the project directory.

- [ ] **[DRY]** Chrome-devtools MCP detection logic is duplicated between `jeeroy.sh` and `install.sh`: Both `jeeroy.sh:validate_environment()` (lines 261-276) and `install.sh` (lines 44-54) contain identical logic to check for the chrome-devtools MCP by looking in two config file locations and grepping for "chrome-devtools". This same check could diverge over time.
  - File(s): `jeeroy.sh` (lines 261-276), `install.sh` (lines 44-54)
  - Fix: Extract the chrome-devtools MCP detection into a shared function in `lib/utils.sh` (e.g., `check_chrome_mcp()`) and call it from both scripts.

- [ ] **[KISS]** `QUICKSTART.md` references `Ralph` as the tool name in several user-facing messages: In `QUICKSTART.md`, lines 167, 261, 333, and 334 refer to "Ralph" (e.g., "Tell Ralph how to build", "When Ralph Stops", "List files to create — Helps Ralph understand scope"). The project has been renamed from Ralph to Walph, and these stale references may confuse users who only know the tool as "Walph."
  - File(s): `QUICKSTART.md` (lines 167, 261, 333, 334)
  - Fix: Replace "Ralph" with "Walph" in the user-facing text of `QUICKSTART.md`. Note: the `specs/README.md` template in `init.sh` (line 242) also references "Ralph" — change to "Walph" there too.

## Out of Scope

- **`--dangerously-skip-permissions` in walph.sh and goodbunny.sh build/fix modes**: This is an intentional and documented design decision. The README explicitly warns users about this and recommends isolated environments. Flagging it would be questioning the project's core architecture.
- **No tests for the shell scripts themselves**: While testing is a review category, adding a bash testing framework (e.g., bats) would be a significant architectural decision and feature addition, not a code quality fix.
- **Hardcoded Postgres credentials (`postgres:postgres`) in Docker templates**: The README explicitly documents these as development-only defaults, and the templates are scaffolding that users are expected to customize.
- **`docker-compose.yml` using deprecated `version` key**: The `version: '3.8'` key in generated docker-compose files is deprecated in newer Docker Compose versions but still functional and widely used. This is a minor deprecation, not a bug.
- **`echo "$output" | grep` pattern used throughout status_parser.sh and circuit_breaker.sh**: Using `echo "$output" | grep` is not ideal (heredoc or `<<<` would be safer for large outputs), but since these are bash scripts and the pattern is consistent, it's a style preference rather than a bug. Changing all instances would be a refactor, not a fix.
